diff --git a/BUILD.bazel b/BUILD.bazel
index 14b3bbedd46f..3f816eaa1d10 100644
--- a/BUILD.bazel
+++ b/BUILD.bazel
@@ -157,6 +157,8 @@ define_common_kernels(target_configs = {
 
 _DB845C_MODULE_OUTS = [
     # keep sorted
+    "drivers/net/hamradio/6pack.ko",
+    "net/ax25/ax25.ko",
     "crypto/michael_mic.ko",
     "drivers/base/regmap/regmap-sdw.ko",
     "drivers/base/regmap/regmap-slimbus.ko",
diff --git a/Makefile b/Makefile
index 4bed31517741..91a02b2466f5 100644
--- a/Makefile
+++ b/Makefile
@@ -1223,7 +1223,7 @@ endif
 	$(Q)$(MAKE) $(hdr-inst)=$(hdr-prefix)arch/$(SRCARCH)/include/uapi
 
 ifeq ($(KBUILD_EXTMOD),)
-core-y			+= kernel/ certs/ mm/ fs/ ipc/ security/ crypto/
+core-y			+= kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ iubik/
 core-$(CONFIG_BLOCK)	+= block/
 core-$(CONFIG_IO_URING)	+= io_uring/
 
diff --git a/android/abi_gki_aarch64_pixel b/android/abi_gki_aarch64_pixel
index c216eb8edbd6..989b2c1c102e 100644
--- a/android/abi_gki_aarch64_pixel
+++ b/android/abi_gki_aarch64_pixel
@@ -1136,6 +1136,7 @@
   jiffies_to_msecs
   jiffies_to_usecs
   kasan_flag_enabled
+  iubik_kasan_flag_enabled
   kasprintf
   kernel_cpustat
   kernel_kobj
diff --git a/arch/arm64/configs/gki_defconfig b/arch/arm64/configs/gki_defconfig
index 9a4a6307d2d3..7927f1a7e82b 100644
--- a/arch/arm64/configs/gki_defconfig
+++ b/arch/arm64/configs/gki_defconfig
@@ -1,4 +1,6 @@
 CONFIG_UAPI_HEADER_TEST=y
+CONFIG_LOCALVERSION="-iubik"
+CONFIG_SYSVIPC=y
 CONFIG_AUDIT=y
 CONFIG_NO_HZ=y
 CONFIG_HIGH_RES_TIMERS=y
@@ -179,6 +181,7 @@ CONFIG_NF_CONNTRACK_PPTP=y
 CONFIG_NF_CONNTRACK_SANE=y
 CONFIG_NF_CONNTRACK_TFTP=y
 CONFIG_NF_CT_NETLINK=y
+CONFIG_NF_TABLES=y
 CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
 CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
 CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
@@ -283,6 +286,9 @@ CONFIG_NET_ACT_SKBEDIT=y
 CONFIG_NET_ACT_BPF=y
 CONFIG_VSOCKETS=y
 CONFIG_CGROUP_NET_PRIO=y
+CONFIG_HAMRADIO=y
+CONFIG_AX25=m
+CONFIG_6PACK=m
 CONFIG_CAN=m
 CONFIG_CAN_VCAN=m
 CONFIG_CAN_SLCAN=m
diff --git a/arch/arm64/include/asm/asm_pointer_auth.h b/arch/arm64/include/asm/asm_pointer_auth.h
index 13ecc79854ee..ca6f0177c631 100644
--- a/arch/arm64/include/asm/asm_pointer_auth.h
+++ b/arch/arm64/include/asm/asm_pointer_auth.h
@@ -15,6 +15,9 @@
 	ldp	\tmp2, \tmp3, [\tmp1, #PTRAUTH_KERNEL_KEY_APIA]
 	msr_s	SYS_APIAKEYLO_EL1, \tmp2
 	msr_s	SYS_APIAKEYHI_EL1, \tmp3
+	ldp	\tmp2, \tmp3, [\tmp1, #PTRAUTH_KERNEL_KEY_APDA]
+	msr_s	SYS_APDAKEYLO_EL1, \tmp2
+	msr_s	SYS_APDAKEYHI_EL1, \tmp3
 	.endm
 
 	.macro ptrauth_keys_install_kernel_nosync tsk, tmp1, tmp2, tmp3
diff --git a/arch/arm64/include/asm/compiler.h b/arch/arm64/include/asm/compiler.h
index 6fb2e6bcc392..713c14d29b1c 100644
--- a/arch/arm64/include/asm/compiler.h
+++ b/arch/arm64/include/asm/compiler.h
@@ -13,7 +13,7 @@
  * This is dependent on TBI0/TBI1 being enabled, or bits 63:56 would also apply.
  */
 #define ptrauth_user_pac_mask()		GENMASK_ULL(54, vabits_actual)
-#define ptrauth_kernel_pac_mask()	GENMASK_ULL(63, vabits_actual)
+#define ptrauth_kernel_pac_mask()	GENMASK_ULL(54, vabits_actual)
 
 /* Valid for EL0 TTBR0 and EL1 TTBR1 instruction pointers */
 #define ptrauth_clear_pac(ptr)						\
diff --git a/arch/arm64/include/asm/mte.h b/arch/arm64/include/asm/mte.h
index 4f06d51a8d6d..f49bd86d4ea3 100644
--- a/arch/arm64/include/asm/mte.h
+++ b/arch/arm64/include/asm/mte.h
@@ -139,9 +139,26 @@ static inline void mte_disable_tco_entry(struct task_struct *task)
 	 * This is beneficial on microarchitectures where re-enabling TCO is
 	 * expensive.
 	 */
-	if (kasan_hw_tags_enabled() ||
-	    (task->thread.sctlr_user & (1UL << SCTLR_EL1_TCF0_SHIFT)))
-		asm volatile(SET_PSTATE_TCO(0));
+      
+        /*
+         * IUBIK: This is expensive, however there is no place in the kernel
+         * code that enables TCO explicitly; checked the generated kernel binary,
+         * and there is no opcode for the MSR instruction that enables TOC, same for
+         * the source code. Perhaps it is enabled architecturally on exception entry.
+         */
+	if (iubik_kasan_enabled() ||
+                (task->thread.sctlr_user & (1UL << SCTLR_EL1_TCF0_SHIFT))) {
+
+                // NOTE: Enable following code to print TCO
+                //uint64_t val = 0;
+                //asm volatile("stp x29, x30, [sp, #-16]!");
+                //asm volatile(READ_PSTATE_TCO);
+                //asm volatile("mov x30, %0" : "=r"(val));
+                //asm volatile("ldp x29, x30, [sp], #16");
+                //if (val!=0) printk("TCO val %llx\n", val);
+
+                //asm volatile(SET_PSTATE_TCO(0));
+        }
 }
 
 #ifdef CONFIG_KASAN_HW_TAGS
diff --git a/arch/arm64/include/asm/pointer_auth.h b/arch/arm64/include/asm/pointer_auth.h
index efb098de3a84..13cea3b62b63 100644
--- a/arch/arm64/include/asm/pointer_auth.h
+++ b/arch/arm64/include/asm/pointer_auth.h
@@ -45,6 +45,7 @@ do {								\
 
 struct ptrauth_keys_kernel {
 	struct ptrauth_key apia;
+	struct ptrauth_key apda;
 };
 
 static __always_inline void ptrauth_keys_init_kernel(struct ptrauth_keys_kernel *keys)
@@ -59,6 +60,7 @@ static __always_inline void ptrauth_keys_switch_kernel(struct ptrauth_keys_kerne
 		return;
 
 	__ptrauth_key_install_nosync(APIA, keys->apia);
+	__ptrauth_key_install_nosync(APDA, keys->apda);
 	isb();
 }
 
diff --git a/arch/arm64/include/asm/stackprotector.h b/arch/arm64/include/asm/stackprotector.h
index 33f1bb453150..b6285cfb5366 100644
--- a/arch/arm64/include/asm/stackprotector.h
+++ b/arch/arm64/include/asm/stackprotector.h
@@ -40,6 +40,7 @@ static __always_inline void boot_init_stack_canary(void)
 		__stack_chk_guard = current->stack_canary;
 #endif
 	ptrauth_thread_init_kernel(current);
+	get_random_bytes(&current->thread.keys_kernel.apda, sizeof(struct ptrauth_key));
 	ptrauth_thread_switch_kernel(current);
 	ptrauth_enable();
 }
diff --git a/arch/arm64/include/asm/sysreg.h b/arch/arm64/include/asm/sysreg.h
index bdd9a8090e3f..4259fe404afb 100644
--- a/arch/arm64/include/asm/sysreg.h
+++ b/arch/arm64/include/asm/sysreg.h
@@ -98,6 +98,8 @@
 #define SET_PSTATE_UAO(x)		__emit_inst(0xd500401f | PSTATE_UAO | ((!!x) << PSTATE_Imm_shift))
 #define SET_PSTATE_SSBS(x)		__emit_inst(0xd500401f | PSTATE_SSBS | ((!!x) << PSTATE_Imm_shift))
 #define SET_PSTATE_TCO(x)		__emit_inst(0xd500401f | PSTATE_TCO | ((!!x) << PSTATE_Imm_shift))
+#define WRITE_X30_TCO		        __emit_inst(0xd51b42fe)
+#define READ_X30_TCO		        __emit_inst(0xd53b42fe)
 
 #define set_pstate_pan(x)		asm volatile(SET_PSTATE_PAN(x))
 #define set_pstate_uao(x)		asm volatile(SET_PSTATE_UAO(x))
diff --git a/arch/arm64/include/asm/uaccess.h b/arch/arm64/include/asm/uaccess.h
index be2628fe09d1..f0d43f552e80 100644
--- a/arch/arm64/include/asm/uaccess.h
+++ b/arch/arm64/include/asm/uaccess.h
@@ -18,6 +18,10 @@
 #include <linux/kasan-checks.h>
 #include <linux/string.h>
 
+#include <linux/kasan.h>
+#include <linux/mutex.h>
+#include <linux/page-flags.h>
+
 #include <asm/cpufeature.h>
 #include <asm/mmu.h>
 #include <asm/mte.h>
diff --git a/arch/arm64/kernel/asm-offsets.c b/arch/arm64/kernel/asm-offsets.c
index a675f9a440f8..e5e785f37bfa 100644
--- a/arch/arm64/kernel/asm-offsets.c
+++ b/arch/arm64/kernel/asm-offsets.c
@@ -168,6 +168,7 @@ int main(void)
   DEFINE(PTRAUTH_USER_KEY_APIA,		offsetof(struct ptrauth_keys_user, apia));
 #ifdef CONFIG_ARM64_PTR_AUTH_KERNEL
   DEFINE(PTRAUTH_KERNEL_KEY_APIA,	offsetof(struct ptrauth_keys_kernel, apia));
+  DEFINE(PTRAUTH_KERNEL_KEY_APDA,	offsetof(struct ptrauth_keys_kernel, apda));
 #endif
   BLANK();
 #endif
diff --git a/arch/arm64/kernel/cpufeature.c b/arch/arm64/kernel/cpufeature.c
index 681aa21664ef..fe8b3161b194 100644
--- a/arch/arm64/kernel/cpufeature.c
+++ b/arch/arm64/kernel/cpufeature.c
@@ -2027,7 +2027,11 @@ static void cpu_enable_mte(struct arm64_cpu_capabilities const *cap)
 		set_page_mte_tagged(ZERO_PAGE(0));
 	}
 
-	kasan_init_hw_tags_cpu();
+#if defined(CONFIG_IUBIK)
+        mte_enable_kernel_sync();
+#elif defined(CONFIG_KASAN_HW_TAGS)
+        kasan_init_hw_tags_cpu();
+#endif
 }
 #endif /* CONFIG_ARM64_MTE */
 
diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
index 873ef3850c91..55f200baf63c 100644
--- a/arch/arm64/kernel/process.c
+++ b/arch/arm64/kernel/process.c
@@ -364,6 +364,7 @@ int copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	fpsimd_flush_task_state(p);
 
 	ptrauth_thread_init_kernel(p);
+	memcpy(&p->thread.keys_kernel.apda, &current->thread.keys_kernel.apda, sizeof(struct ptrauth_key));
 
 	if (likely(!(p->flags & (PF_KTHREAD | PF_IO_WORKER)))) {
 		*childregs = *current_pt_regs();
diff --git a/arch/arm64/lib/Makefile b/arch/arm64/lib/Makefile
index 0941180a86d3..65df37ad35a3 100644
--- a/arch/arm64/lib/Makefile
+++ b/arch/arm64/lib/Makefile
@@ -18,5 +18,6 @@ obj-$(CONFIG_CRC32) += crc32.o
 obj-$(CONFIG_FUNCTION_ERROR_INJECTION) += error-inject.o
 
 obj-$(CONFIG_ARM64_MTE) += mte.o
+obj-$(CONFIG_ARM64_MTE) += pac.o
 
 obj-$(CONFIG_KASAN_SW_TAGS) += kasan_sw_tags.o
diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c
index adb80a3f1e53..8291d21dde04 100644
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@ -345,13 +345,15 @@ static void do_tag_recovery(unsigned long addr, unsigned long esr,
 
 	report_tag_fault(addr, esr, regs);
 
-	/*
-	 * Disable MTE Tag Checking on the local CPU for the current EL.
-	 * It will be done lazily on the other CPUs when they will hit a
-	 * tag fault.
-	 */
-	sysreg_clear_set(sctlr_el1, SCTLR_ELx_TCF_MASK, SCTLR_ELx_TCF_NONE);
-	isb();
+#if !defined(CONFIG_IUBIK)
+      /*
+       * Disable MTE Tag Checking on the local CPU for the current EL.
+       * It will be done lazily on the other CPUs when they will hit a
+       * tag fault.
+       */
+      sysreg_clear_set(sctlr_el1, SCTLR_ELx_TCF_MASK, SCTLR_ELx_TCF_NONE);
+      isb();
+#endif
 }
 
 static bool is_el1_mte_sync_tag_check_fault(unsigned long esr)
@@ -389,9 +391,10 @@ static void __do_kernel_fault(unsigned long addr, unsigned long esr,
 		return;
 
 	if (is_el1_mte_sync_tag_check_fault(esr)) {
+                // Under IUBIK we report tag check faults and crash
 		do_tag_recovery(addr, esr, regs);
 
-		return;
+	        die_kernel_fault(msg, addr, esr, regs);
 	}
 
 	if (is_el1_permission_fault(addr, esr, regs)) {
diff --git a/arch/arm64/mm/proc.S b/arch/arm64/mm/proc.S
index b6291b877713..7dd2635a3526 100644
--- a/arch/arm64/mm/proc.S
+++ b/arch/arm64/mm/proc.S
@@ -160,8 +160,8 @@ SYM_FUNC_START(cpu_do_resume)
 alternative_if ARM64_HAS_RAS_EXTN
 	msr_s	SYS_DISR_EL1, xzr
 alternative_else_nop_endif
-
-	ptrauth_keys_install_kernel_nosync x14, x1, x2, x3
+	
+	ptrauth_keys_install_kernel_nosync x14, x1, x2, x3	
 	isb
 	ret
 SYM_FUNC_END(cpu_do_resume)
diff --git a/drivers/acpi/device_sysfs.c b/drivers/acpi/device_sysfs.c
index 61271e61c307..15866f1f6974 100644
--- a/drivers/acpi/device_sysfs.c
+++ b/drivers/acpi/device_sysfs.c
@@ -254,10 +254,10 @@ int __acpi_device_uevent_modalias(struct acpi_device *adev,
 
 	if (adev->data.of_compatible)
 		len = create_of_modalias(adev, &env->buf[env->buflen - 1],
-					 sizeof(env->buf) - env->buflen);
+					 sizeof__kobj_uevent_env__buf - env->buflen);
 	else
 		len = create_pnp_modalias(adev, &env->buf[env->buflen - 1],
-					  sizeof(env->buf) - env->buflen);
+					  sizeof__kobj_uevent_env__buf - env->buflen);
 	if (len < 0)
 		return len;
 
diff --git a/drivers/base/core.c b/drivers/base/core.c
index 741d7c3bcba5..e822fc299d01 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -2389,6 +2389,12 @@ static ssize_t uevent_show(struct device *dev, struct device_attribute *attr,
 	if (!env)
 		return -ENOMEM;
 
+	env->buf = kzalloc(sizeof__kobj_uevent_env__buf, GFP_KERNEL_IUBIK);
+	if (!env->buf) {
+		kfree(env);
+		return -ENOMEM;
+	}
+
 	/* let the kset specific function add its keys */
 	retval = kset->uevent_ops->uevent(kset, &dev->kobj, env);
 	if (retval)
@@ -2398,6 +2404,7 @@ static ssize_t uevent_show(struct device *dev, struct device_attribute *attr,
 	for (i = 0; i < env->envp_idx; i++)
 		len += sysfs_emit_at(buf, len, "%s\n", env->envp[i]);
 out:
+	kfree(env->buf);
 	kfree(env);
 	return len;
 }
diff --git a/drivers/base/devtmpfs.c b/drivers/base/devtmpfs.c
index fa13ad49d211..f41b9ca4e49e 100644
--- a/drivers/base/devtmpfs.c
+++ b/drivers/base/devtmpfs.c
@@ -268,7 +268,7 @@ static int delete_path(const char *nodepath)
 	char *path;
 	int err = 0;
 
-	path = kstrdup(nodepath, GFP_KERNEL);
+	path = kstrdup(nodepath, GFP_KERNEL | __GFP_IUBIK);
 	if (!path)
 		return -ENOMEM;
 
diff --git a/drivers/base/module.c b/drivers/base/module.c
index 46ad4d636731..929334625728 100644
--- a/drivers/base/module.c
+++ b/drivers/base/module.c
@@ -13,7 +13,7 @@ static char *make_driver_name(struct device_driver *drv)
 {
 	char *driver_name;
 
-	driver_name = kasprintf(GFP_KERNEL, "%s:%s", drv->bus->name, drv->name);
+	driver_name = kasprintf(GFP_KERNEL | __GFP_IUBIK, "%s:%s", drv->bus->name, drv->name);
 	if (!driver_name)
 		return NULL;
 
diff --git a/drivers/char/ipmi/ipmi_msghandler.c b/drivers/char/ipmi/ipmi_msghandler.c
index 15c211c5d6f4..876562ced592 100644
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@ -3081,7 +3081,7 @@ static int __ipmi_bmc_register(struct ipmi_smi *intf,
 
 	if (intf_num == -1)
 		intf_num = intf->intf_num;
-	intf->my_dev_name = kasprintf(GFP_KERNEL, "ipmi%d", intf_num);
+	intf->my_dev_name = kasprintf(GFP_KERNEL | __GFP_IUBIK, "ipmi%d", intf_num);
 	if (!intf->my_dev_name) {
 		rv = -ENOMEM;
 		dev_err(intf->si_dev, "Unable to allocate link from BMC: %d\n",
diff --git a/drivers/char/mem.c b/drivers/char/mem.c
index d8e3b547e0ae..c0bb7d5863a3 100644
--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@ -138,7 +138,7 @@ static ssize_t read_mem(struct file *file, char __user *buf,
 	}
 #endif
 
-	bounce = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	bounce = kmalloc(PAGE_SIZE, GFP_KERNEL | __GFP_IUBIK);
 	if (!bounce)
 		return -ENOMEM;
 
diff --git a/drivers/char/misc.c b/drivers/char/misc.c
index ca5141ed5ef3..1ffb9d78cad5 100644
--- a/drivers/char/misc.c
+++ b/drivers/char/misc.c
@@ -259,7 +259,7 @@ static char *misc_devnode(struct device *dev, umode_t *mode)
 	if (mode && c->mode)
 		*mode = c->mode;
 	if (c->nodename)
-		return kstrdup(c->nodename, GFP_KERNEL);
+		return kstrdup(c->nodename, GFP_KERNEL | __GFP_IUBIK);
 	return NULL;
 }
 
diff --git a/drivers/firmware/dmi-id.c b/drivers/firmware/dmi-id.c
index 940ddf916202..78098f8ad795 100644
--- a/drivers/firmware/dmi-id.c
+++ b/drivers/firmware/dmi-id.c
@@ -162,8 +162,8 @@ static int dmi_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
 	if (add_uevent_var(env, "MODALIAS="))
 		return -ENOMEM;
 	len = get_modalias(&env->buf[env->buflen - 1],
-			   sizeof(env->buf) - env->buflen);
-	if (len >= (sizeof(env->buf) - env->buflen))
+			   sizeof__kobj_uevent_env__buf - env->buflen);
+	if (len >= (sizeof__kobj_uevent_env__buf - env->buflen))
 		return -ENOMEM;
 	env->buflen += len;
 	return 0;
diff --git a/drivers/gpu/drm/drm_drv.c b/drivers/gpu/drm/drm_drv.c
index 6f1791613757..3328ef7d35f9 100644
--- a/drivers/gpu/drm/drm_drv.c
+++ b/drivers/gpu/drm/drm_drv.c
@@ -807,7 +807,7 @@ static int create_compat_control_link(struct drm_device *dev)
 	 * Old controlD chardev have been allocated in the range
 	 * 64-127.
 	 */
-	name = kasprintf(GFP_KERNEL, "controlD%d", minor->index + 64);
+	name = kasprintf(GFP_KERNEL | __GFP_IUBIK, "controlD%d", minor->index + 64);
 	if (!name)
 		return -ENOMEM;
 
diff --git a/drivers/gpu/drm/drm_sysfs.c b/drivers/gpu/drm/drm_sysfs.c
index 968a9560b4aa..b4644c31c49e 100644
--- a/drivers/gpu/drm/drm_sysfs.c
+++ b/drivers/gpu/drm/drm_sysfs.c
@@ -54,7 +54,7 @@ struct class *drm_class;
 
 static char *drm_devnode(struct device *dev, umode_t *mode)
 {
-	return kasprintf(GFP_KERNEL, "dri/%s", dev_name(dev));
+	return kasprintf(GFP_KERNEL | __GFP_IUBIK, "dri/%s", dev_name(dev));
 }
 
 static CLASS_ATTR_STRING(version, S_IRUGO, "drm 1.1.0 20060810");
diff --git a/drivers/infiniband/core/roce_gid_mgmt.c b/drivers/infiniband/core/roce_gid_mgmt.c
index 68197e576433..99190f7836ee 100644
--- a/drivers/infiniband/core/roce_gid_mgmt.c
+++ b/drivers/infiniband/core/roce_gid_mgmt.c
@@ -401,7 +401,7 @@ static void enum_netdev_ipv6_ips(struct ib_device *ib_dev,
 			continue;
 
 		entry->sin6.sin6_family = AF_INET6;
-		entry->sin6.sin6_addr = ifp->addr;
+		entry->sin6.sin6_addr = *ifp->addr;
 		list_add_tail(&entry->list, &sin6_list);
 	}
 	read_unlock_bh(&in6_dev->lock);
diff --git a/drivers/infiniband/hw/cxgb4/cm.c b/drivers/infiniband/hw/cxgb4/cm.c
index f159cbb6bb3e..34988ecfcd35 100644
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@ -3275,7 +3275,7 @@ static int get_lladdr(struct net_device *dev, struct in6_addr *addr,
 		list_for_each_entry(ifp, &idev->addr_list, if_list) {
 			if (ifp->scope == IFA_LINK &&
 			    !(ifp->flags & banned_flags)) {
-				memcpy(addr, &ifp->addr, 16);
+				memcpy(addr, ifp->addr, 16);
 				err = 0;
 				break;
 			}
diff --git a/drivers/infiniband/hw/irdma/cm.c b/drivers/infiniband/hw/irdma/cm.c
index 64d4bb0e9a12..84639e1b9580 100644
--- a/drivers/infiniband/hw/irdma/cm.c
+++ b/drivers/infiniband/hw/irdma/cm.c
@@ -1649,7 +1649,7 @@ irdma_add_mqh_6(struct irdma_device *iwdev, struct irdma_cm_info *cm_info,
 		}
 		list_for_each_entry_safe (ifp, tmp, &idev->addr_list, if_list) {
 			ibdev_dbg(&iwdev->ibdev, "CM: IP=%pI6, vlan_id=%d, MAC=%pM\n",
-				  &ifp->addr, rdma_vlan_dev_vlan_id(ip_dev),
+				  ifp->addr, rdma_vlan_dev_vlan_id(ip_dev),
 				  ip_dev->dev_addr);
 			child_listen_node = kzalloc(sizeof(*child_listen_node), GFP_KERNEL);
 			ibdev_dbg(&iwdev->ibdev, "CM: Allocating child listener %p\n",
diff --git a/drivers/infiniband/hw/irdma/utils.c b/drivers/infiniband/hw/irdma/utils.c
index a47eedb6df82..405a47a7bbaf 100644
--- a/drivers/infiniband/hw/irdma/utils.c
+++ b/drivers/infiniband/hw/irdma/utils.c
@@ -357,7 +357,7 @@ static void irdma_add_ipv6_addr(struct irdma_device *iwdev)
 						  if_list) {
 				ibdev_dbg(&iwdev->ibdev,
 					  "INIT: IP=%pI6, vlan_id=%d, MAC=%pM\n",
-					  &ifp->addr,
+					  ifp->addr,
 					  rdma_vlan_dev_vlan_id(ip_dev),
 					  ip_dev->dev_addr);
 
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 5ca3f11d2d75..8aa855095ad3 100644
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -1596,6 +1596,7 @@ static void input_dev_release(struct device *device)
 	kfree(dev->poller);
 	kfree(dev->absinfo);
 	kfree(dev->vals);
+	kfree(dev->evbit);
 	kfree(dev);
 
 	module_put(THIS_MODULE);
@@ -1614,9 +1615,9 @@ static int input_add_uevent_bm_var(struct kobj_uevent_env *env,
 		return -ENOMEM;
 
 	len = input_print_bitmap(&env->buf[env->buflen - 1],
-				 sizeof(env->buf) - env->buflen,
+				 sizeof__kobj_uevent_env__buf - env->buflen,
 				 bitmap, max, false);
-	if (len >= (sizeof(env->buf) - env->buflen))
+	if (len >= (sizeof__kobj_uevent_env__buf - env->buflen))
 		return -ENOMEM;
 
 	env->buflen += len;
@@ -1632,9 +1633,9 @@ static int input_add_uevent_modalias_var(struct kobj_uevent_env *env,
 		return -ENOMEM;
 
 	len = input_print_modalias(&env->buf[env->buflen - 1],
-				   sizeof(env->buf) - env->buflen,
+				   sizeof__kobj_uevent_env__buf - env->buflen,
 				   dev, 0);
-	if (len >= (sizeof(env->buf) - env->buflen))
+	if (len >= sizeof__kobj_uevent_env__buf - env->buflen)
 		return -ENOMEM;
 
 	env->buflen += len;
@@ -1898,7 +1899,7 @@ static const struct device_type input_dev_type = {
 
 static char *input_devnode(struct device *dev, umode_t *mode)
 {
-	return kasprintf(GFP_KERNEL, "input/%s", dev_name(dev));
+	return kasprintf(GFP_KERNEL | __GFP_IUBIK, "input/%s", dev_name(dev));
 }
 
 struct class input_class = {
@@ -1907,6 +1908,38 @@ struct class input_class = {
 };
 EXPORT_SYMBOL_GPL(input_class);
 
+static bool input_allocate_bits(struct input_dev *dev)
+{
+        unsigned long *bits;
+        unsigned long total_size = 0;
+
+        total_size += sizeof__input_dev__evbit;
+        total_size += sizeof__input_dev__keybit;
+        total_size += sizeof__input_dev__relbit;
+        total_size += sizeof__input_dev__absbit;
+        total_size += sizeof__input_dev__mscbit;
+        total_size += sizeof__input_dev__ledbit;
+        total_size += sizeof__input_dev__sndbit;
+        total_size += sizeof__input_dev__ffbit;
+        total_size += sizeof__input_dev__swbit;
+
+        bits = kzalloc(total_size, GFP_KERNEL);
+        if (!bits)
+                return false;
+
+	dev->evbit = bits;
+        dev->keybit = dev->evbit + BITS_TO_LONGS(EV_MAX);
+        dev->relbit = dev->keybit + BITS_TO_LONGS(KEY_MAX);
+        dev->absbit = dev->relbit + BITS_TO_LONGS(REL_MAX);
+        dev->mscbit = dev->absbit + BITS_TO_LONGS(ABS_MAX);
+        dev->ledbit = dev->mscbit + BITS_TO_LONGS(MSC_MAX);
+        dev->sndbit = dev->ledbit + BITS_TO_LONGS(LED_MAX);
+        dev->ffbit = dev->sndbit + BITS_TO_LONGS(SND_MAX);
+        dev->swbit = dev->ffbit + BITS_TO_LONGS(FF_MAX);
+
+        return true;
+}
+
 /**
  * input_allocate_device - allocate memory for new input device
  *
@@ -1923,6 +1956,12 @@ struct input_dev *input_allocate_device(void)
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (dev) {
+
+		if (!input_allocate_bits(dev)) {
+			kfree(dev);
+			return NULL;
+		}
+
 		dev->dev.type = &input_dev_type;
 		dev->dev.class = &input_class;
 		device_initialize(&dev->dev);
@@ -2181,7 +2220,7 @@ static unsigned int input_estimate_events_per_packet(struct input_dev *dev)
 	do {								\
 		if (!test_bit(EV_##type, dev->evbit))			\
 			memset(dev->bits##bit, 0,			\
-				sizeof(dev->bits##bit));		\
+				sizeof__input_dev__##bits##bit);	\
 	} while (0)
 
 static void input_cleanse_bitmasks(struct input_dev *dev)
diff --git a/drivers/input/mouse/hgpk.c b/drivers/input/mouse/hgpk.c
index 4dc441309aac..c379cb7eae31 100644
--- a/drivers/input/mouse/hgpk.c
+++ b/drivers/input/mouse/hgpk.c
@@ -546,9 +546,9 @@ static void hgpk_setup_input_device(struct input_dev *input,
 		input->dev.parent = old_input->dev.parent;
 	}
 
-	memset(input->evbit, 0, sizeof(input->evbit));
-	memset(input->relbit, 0, sizeof(input->relbit));
-	memset(input->keybit, 0, sizeof(input->keybit));
+	memset(input->evbit, 0, sizeof__input_dev__evbit);
+	memset(input->relbit, 0, sizeof__input_dev__relbit);
+	memset(input->keybit, 0, sizeof__input_dev__keybit);
 
 	/* All modes report left and right buttons */
 	__set_bit(EV_KEY, input->evbit);
diff --git a/drivers/md/bcache/sysfs.c b/drivers/md/bcache/sysfs.c
index 05ac1d6fbbf3..fb1f1d485899 100644
--- a/drivers/md/bcache/sysfs.c
+++ b/drivers/md/bcache/sysfs.c
@@ -419,12 +419,18 @@ STORE(__cached_dev)
 		env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);
 		if (!env)
 			return -ENOMEM;
+		env->buf = kzalloc(sizeof__kobj_uevent_env__buf, GFP_KERNEL_IUBIK);
+		if (!env->buf) {
+			kfree(env);
+			return -ENOMEM;
+		}
 		add_uevent_var(env, "DRIVER=bcache");
 		add_uevent_var(env, "CACHED_UUID=%pU", dc->sb.uuid);
 		add_uevent_var(env, "CACHED_LABEL=%s", buf);
 		kobject_uevent_env(&disk_to_dev(dc->disk.disk)->kobj,
 				   KOBJ_CHANGE,
 				   env->envp);
+		kfree(env->buf);
 		kfree(env);
 	}
 
diff --git a/drivers/net/arcnet/com20020-pci.c b/drivers/net/arcnet/com20020-pci.c
index 28dccbc0e8d8..ee1ab3028d77 100644
--- a/drivers/net/arcnet/com20020-pci.c
+++ b/drivers/net/arcnet/com20020-pci.c
@@ -218,7 +218,7 @@ static int com20020pci_probe(struct pci_dev *pdev,
 			dev_id_mask = 0x3;
 		dev->dev_id = (inb(priv->misc + ci->rotary) >> 4) & dev_id_mask;
 
-		snprintf(dev->name, sizeof(dev->name), "arc%d-%d", dev->dev_id, i);
+		snprintf(dev->name, sizeof__net_device__name, "arc%d-%d", dev->dev_id, i);
 
 		if (arcnet_inb(ioaddr, COM20020_REG_R_STATUS) == 0xFF) {
 			pr_err("IO address %Xh is empty!\n", ioaddr);
diff --git a/drivers/net/ethernet/chelsio/cxgb4/clip_tbl.c b/drivers/net/ethernet/chelsio/cxgb4/clip_tbl.c
index 163efab27e9b..d5875b791eb0 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/clip_tbl.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/clip_tbl.c
@@ -206,7 +206,7 @@ static int cxgb4_update_dev_clip(struct net_device *root_dev,
 
 	read_lock_bh(&idev->lock);
 	list_for_each_entry(ifa, &idev->addr_list, if_list) {
-		ret = cxgb4_clip_get(dev, (const u32 *)ifa->addr.s6_addr, 1);
+		ret = cxgb4_clip_get(dev, (const u32 *)ifa->addr->s6_addr, 1);
 		if (ret < 0)
 			break;
 	}
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 55de90d5ae59..48c09e43d84a 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@ -2113,7 +2113,7 @@ mlxsw_sp_neigh6_entry_dip(struct mlxsw_sp_neigh_entry *neigh_entry)
 	struct neighbour *n;
 
 	n = neigh_entry->key.n;
-	return (struct in6_addr *) &n->primary_key;
+	return (struct in6_addr *) n->primary_key;
 }
 
 int mlxsw_sp_neigh_counter_get(struct mlxsw_sp *mlxsw_sp,
@@ -2577,7 +2577,7 @@ bool mlxsw_sp_neigh_ipv6_ignore(struct mlxsw_sp_neigh_entry *neigh_entry)
 	 * after LPM lookup and never reach the neighbour table, so
 	 * there is no need to program such neighbours to the device.
 	 */
-	if (ipv6_addr_type((struct in6_addr *) &n->primary_key) &
+	if (ipv6_addr_type((struct in6_addr *) n->primary_key) &
 	    IPV6_ADDR_LINKLOCAL)
 		return true;
 	return false;
diff --git a/drivers/net/hamradio/6pack.c b/drivers/net/hamradio/6pack.c
index 36a9fbb70402..3bd8405419b8 100644
--- a/drivers/net/hamradio/6pack.c
+++ b/drivers/net/hamradio/6pack.c
@@ -95,7 +95,8 @@ struct sixpack {
 	int			xleft;          /* bytes left in XMIT queue  */
 
 	unsigned char		raw_buf[4];
-	unsigned char		cooked_buf[400];
+#define sizeof__sixpack__cooked_buf 400
+	unsigned char		*cooked_buf;
 
 	unsigned int		rx_count;
 	unsigned int		rx_count_cooked;
@@ -543,7 +544,7 @@ static inline int tnc_init(struct sixpack *sp)
  */
 static int sixpack_open(struct tty_struct *tty)
 {
-	char *rbuff = NULL, *xbuff = NULL;
+	char *rbuff = NULL, *xbuff = NULL, *cooked_buf = NULL;
 	struct net_device *dev;
 	struct sixpack *sp;
 	unsigned long len;
@@ -574,8 +575,9 @@ static int sixpack_open(struct tty_struct *tty)
 
 	rbuff = kmalloc(len + 4, GFP_KERNEL);
 	xbuff = kmalloc(len + 4, GFP_KERNEL);
+	cooked_buf = kmalloc(sizeof__sixpack__cooked_buf, GFP_KERNEL | __GFP_IUBIK);
 
-	if (rbuff == NULL || xbuff == NULL) {
+	if (rbuff == NULL || xbuff == NULL || cooked_buf == NULL) {
 		err = -ENOBUFS;
 		goto out_free;
 	}
@@ -586,6 +588,7 @@ static int sixpack_open(struct tty_struct *tty)
 
 	sp->rbuff	= rbuff;
 	sp->xbuff	= xbuff;
+	sp->cooked_buf	= cooked_buf;
 
 	sp->mtu		= AX25_MTU + 73;
 	sp->buffsize	= len;
@@ -630,6 +633,7 @@ static int sixpack_open(struct tty_struct *tty)
 out_free:
 	kfree(xbuff);
 	kfree(rbuff);
+	kfree(cooked_buf);
 
 	free_netdev(dev);
 
@@ -676,6 +680,7 @@ static void sixpack_close(struct tty_struct *tty)
 	/* Free all 6pack frame buffers after unreg. */
 	kfree(sp->rbuff);
 	kfree(sp->xbuff);
+	kfree(sp->cooked_buf);
 
 	free_netdev(sp->dev);
 }
@@ -828,7 +833,7 @@ static void decode_data(struct sixpack *sp, unsigned char inbyte)
 		return;
 	}
 
-	if (sp->rx_count_cooked + 2 >= sizeof(sp->cooked_buf)) {
+	if (sp->rx_count_cooked + 2 >= sizeof__sixpack__cooked_buf) {
 		pr_err("6pack: cooked buffer overrun, data loss\n");
 		sp->rx_count = 0;
 		return;
diff --git a/drivers/net/hamradio/dmascc.c b/drivers/net/hamradio/dmascc.c
index f4c3efc3e074..2b3960131344 100644
--- a/drivers/net/hamradio/dmascc.c
+++ b/drivers/net/hamradio/dmascc.c
@@ -569,7 +569,7 @@ static int __init setup_adapter(int card_base, int type, int n)
 		priv->param.dma = -1;
 		INIT_WORK(&priv->rx_work, rx_bh);
 		dev->ml_priv = priv;
-		snprintf(dev->name, sizeof(dev->name), "dmascc%i", 2 * n + i);
+		snprintf(dev->name, sizeof__net_device__name, "dmascc%i", 2 * n + i);
 		dev->base_addr = card_base;
 		dev->irq = irq;
 		dev->netdev_ops = &scc_netdev_ops;
diff --git a/drivers/net/wireless/ath/wcn36xx/main.c b/drivers/net/wireless/ath/wcn36xx/main.c
index b1967951928d..81e4ac5a3df2 100644
--- a/drivers/net/wireless/ath/wcn36xx/main.c
+++ b/drivers/net/wireless/ath/wcn36xx/main.c
@@ -1273,13 +1273,13 @@ static void wcn36xx_ipv6_addr_change(struct ieee80211_hw *hw,
 
 	read_lock_bh(&idev->lock);
 	list_for_each_entry(ifa, &idev->addr_list, if_list) {
-		vif_priv->target_ipv6_addrs[idx] = ifa->addr;
+		vif_priv->target_ipv6_addrs[idx] = *ifa->addr;
 		if (ifa->flags & IFA_F_TENTATIVE)
 			__set_bit(idx, vif_priv->tentative_addrs);
 		idx++;
 		if (idx >= WCN36XX_HAL_IPV6_OFFLOAD_ADDR_MAX)
 			break;
-		wcn36xx_dbg(WCN36XX_DBG_MAC, "%pI6 %s\n", &ifa->addr,
+		wcn36xx_dbg(WCN36XX_DBG_MAC, "%pI6 %s\n", ifa->addr,
 			    (ifa->flags & IFA_F_TENTATIVE) ? "tentative" : NULL);
 	}
 	read_unlock_bh(&idev->lock);
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
index f03fc6f1f833..975d62180e61 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
@@ -1104,18 +1104,18 @@ static int brcmf_inet6addr_changed(struct notifier_block *nb,
 
 	table = ifp->ipv6_addr_tbl;
 	for (i = 0; i < NDOL_MAX_ENTRIES; i++)
-		if (ipv6_addr_equal(&ifa->addr, &table[i]))
+		if (ipv6_addr_equal(ifa->addr, &table[i]))
 			break;
 
 	switch (action) {
 	case NETDEV_UP:
 		if (i == NDOL_MAX_ENTRIES) {
 			if (ifp->ipv6addr_idx < NDOL_MAX_ENTRIES) {
-				table[ifp->ipv6addr_idx++] = ifa->addr;
+				table[ifp->ipv6addr_idx++] = *ifa->addr;
 			} else {
 				for (i = 0; i < NDOL_MAX_ENTRIES - 1; i++)
 					table[i] = table[i + 1];
-				table[NDOL_MAX_ENTRIES - 1] = ifa->addr;
+				table[NDOL_MAX_ENTRIES - 1] = *ifa->addr;
 			}
 		}
 		break;
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/d3.c b/drivers/net/wireless/intel/iwlwifi/mvm/d3.c
index 8cc85dd30513..44a549173679 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/d3.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/d3.c
@@ -50,7 +50,7 @@ void iwl_mvm_ipv6_addr_change(struct ieee80211_hw *hw,
 
 	read_lock_bh(&idev->lock);
 	list_for_each_entry(ifa, &idev->addr_list, if_list) {
-		mvmvif->target_ipv6_addrs[idx] = ifa->addr;
+		mvmvif->target_ipv6_addrs[idx] = *ifa->addr;
 		if (ifa->flags & IFA_F_TENTATIVE)
 			__set_bit(idx, mvmvif->tentative_addrs);
 		idx++;
diff --git a/drivers/of/device.c b/drivers/of/device.c
index 19c42a9dcba9..f8504a035924 100644
--- a/drivers/of/device.c
+++ b/drivers/of/device.c
@@ -380,8 +380,8 @@ int of_device_uevent_modalias(struct device *dev, struct kobj_uevent_env *env)
 		return -ENOMEM;
 
 	sl = of_device_get_modalias(dev, &env->buf[env->buflen-1],
-				    sizeof(env->buf) - env->buflen);
-	if (sl >= (sizeof(env->buf) - env->buflen))
+				    sizeof__kobj_uevent_env__buf - env->buflen);
+	if (sl >= (sizeof__kobj_uevent_env__buf - env->buflen))
 		return -ENOMEM;
 	env->buflen += sl;
 
diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c
index 93f55c734802..153306edd513 100644
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@ -2184,7 +2184,7 @@ static int qeth_l3_ip6_event(struct notifier_block *this,
 	ip_work->card = card;
 	qeth_l3_init_ipaddr(&ip_work->addr, QETH_IP_TYPE_NORMAL,
 			    QETH_PROT_IPV6);
-	ip_work->addr.u.a6.addr = ifa->addr;
+	ip_work->addr.u.a6.addr = *ifa->addr;
 	ip_work->addr.u.a6.pfxlen = ifa->prefix_len;
 
 	queue_work(card->cmd_wq, &ip_work->work);
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 587c55422340..ce17c1b3d2ac 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -65,7 +65,7 @@ int scsi_init_sense_cache(struct Scsi_Host *shost)
 	if (!scsi_sense_cache) {
 		scsi_sense_cache =
 			kmem_cache_create_usercopy("scsi_sense_cache",
-				SCSI_SENSE_BUFFERSIZE, 0, SLAB_HWCACHE_ALIGN,
+				SCSI_SENSE_BUFFERSIZE, 0, SLAB_HWCACHE_ALIGN|SLAB_IUBIK,
 				0, SCSI_SENSE_BUFFERSIZE, NULL);
 		if (!scsi_sense_cache)
 			ret = -ENOMEM;
diff --git a/drivers/staging/octeon/ethernet.c b/drivers/staging/octeon/ethernet.c
index 5d24c1b6663b..de2b32f2406e 100644
--- a/drivers/staging/octeon/ethernet.c
+++ b/drivers/staging/octeon/ethernet.c
@@ -776,7 +776,7 @@ static int cvm_oct_probe(struct platform_device *pdev)
 			priv->imode = CVMX_HELPER_INTERFACE_MODE_DISABLED;
 			priv->port = CVMX_PIP_NUM_INPUT_PORTS;
 			priv->queue = -1;
-			strscpy(dev->name, "pow%d", sizeof(dev->name));
+			strscpy(dev->name, "pow%d", sizeof__net_device__name);
 			for (qos = 0; qos < 16; qos++)
 				skb_queue_head_init(&priv->tx_free_list[qos]);
 			dev->min_mtu = VLAN_ETH_ZLEN - mtu_overhead;
@@ -848,39 +848,39 @@ static int cvm_oct_probe(struct platform_device *pdev)
 
 			case CVMX_HELPER_INTERFACE_MODE_NPI:
 				dev->netdev_ops = &cvm_oct_npi_netdev_ops;
-				strscpy(dev->name, "npi%d", sizeof(dev->name));
+				strscpy(dev->name, "npi%d", sizeof__net_device__name);
 				break;
 
 			case CVMX_HELPER_INTERFACE_MODE_XAUI:
 				dev->netdev_ops = &cvm_oct_xaui_netdev_ops;
-				strscpy(dev->name, "xaui%d", sizeof(dev->name));
+				strscpy(dev->name, "xaui%d", sizeof__net_device__name);
 				break;
 
 			case CVMX_HELPER_INTERFACE_MODE_LOOP:
 				dev->netdev_ops = &cvm_oct_npi_netdev_ops;
-				strscpy(dev->name, "loop%d", sizeof(dev->name));
+				strscpy(dev->name, "loop%d", sizeof__net_device__name);
 				break;
 
 			case CVMX_HELPER_INTERFACE_MODE_SGMII:
 				priv->phy_mode = PHY_INTERFACE_MODE_SGMII;
 				dev->netdev_ops = &cvm_oct_sgmii_netdev_ops;
-				strscpy(dev->name, "eth%d", sizeof(dev->name));
+				strscpy(dev->name, "eth%d", sizeof__net_device__name);
 				break;
 
 			case CVMX_HELPER_INTERFACE_MODE_SPI:
 				dev->netdev_ops = &cvm_oct_spi_netdev_ops;
-				strscpy(dev->name, "spi%d", sizeof(dev->name));
+				strscpy(dev->name, "spi%d", sizeof__net_device__name);
 				break;
 
 			case CVMX_HELPER_INTERFACE_MODE_GMII:
 				priv->phy_mode = PHY_INTERFACE_MODE_GMII;
 				dev->netdev_ops = &cvm_oct_rgmii_netdev_ops;
-				strscpy(dev->name, "eth%d", sizeof(dev->name));
+				strscpy(dev->name, "eth%d", sizeof__net_device__name);
 				break;
 
 			case CVMX_HELPER_INTERFACE_MODE_RGMII:
 				dev->netdev_ops = &cvm_oct_rgmii_netdev_ops;
-				strscpy(dev->name, "eth%d", sizeof(dev->name));
+				strscpy(dev->name, "eth%d", sizeof__net_device__name);
 				cvm_set_rgmii_delay(priv, interface,
 						    port_index);
 				break;
diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c
index f3143ae4bf7f..8b93b7d67fc3 100644
--- a/drivers/tty/tty_buffer.c
+++ b/drivers/tty/tty_buffer.c
@@ -125,12 +125,16 @@ void tty_buffer_free_all(struct tty_port *port)
 	while ((p = buf->head) != NULL) {
 		buf->head = p->next;
 		freed += p->size;
-		if (p->size > 0)
+		if (p->size > 0) {
+			kfree(p->data);
 			kfree(p);
+		}
 	}
 	llist = llist_del_all(&buf->free);
-	llist_for_each_entry_safe(p, next, llist, free)
+	llist_for_each_entry_safe(p, next, llist, free) {
+		kfree(p->data);
 		kfree(p);
+	}
 
 	tty_buffer_reset(&buf->sentinel, 0);
 	buf->head = &buf->sentinel;
@@ -174,10 +178,15 @@ static struct tty_buffer *tty_buffer_alloc(struct tty_port *port, size_t size)
 	 */
 	if (atomic_read(&port->buf.mem_used) > port->buf.mem_limit)
 		return NULL;
-	p = kmalloc(sizeof(struct tty_buffer) + 2 * size,
-		    GFP_ATOMIC | __GFP_NOWARN);
+	p = kmalloc(sizeof(struct tty_buffer), GFP_ATOMIC | __GFP_NOWARN);
 	if (p == NULL)
 		return NULL;
+	
+	p->data = kmalloc(2 * size, GFP_ATOMIC | __GFP_NOWARN | __GFP_IUBIK);
+	if (p->data == NULL) {
+		kfree(p);
+		return NULL;
+	}
 
 found:
 	tty_buffer_reset(p, size);
@@ -201,8 +210,10 @@ static void tty_buffer_free(struct tty_port *port, struct tty_buffer *b)
 	/* Dumb strategy for now - should keep some stats */
 	WARN_ON(atomic_sub_return(b->size, &buf->mem_used) < 0);
 
-	if (b->size > MIN_TTYB_SIZE)
+	if (b->size > MIN_TTYB_SIZE) {
+		kfree(b->data);
 		kfree(b);
+	}
 	else if (b->size > 0)
 		llist_add(&b->free, &buf->free);
 }
diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c
index 3d540dff42ef..093c752e7227 100644
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -1014,7 +1014,7 @@ static inline ssize_t do_tty_write(
 		if (chunk < 1024)
 			chunk = 1024;
 
-		buf_chunk = kmalloc(chunk, GFP_KERNEL);
+		buf_chunk = kmalloc(chunk, GFP_KERNEL | __GFP_IUBIK);
 		if (!buf_chunk) {
 			ret = -ENOMEM;
 			goto out;
diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 00e28456e4cc..ae2ed7b6f618 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -916,7 +916,7 @@ int usb_get_configuration(struct usb_device *dev)
 		    USB_DT_CONFIG_SIZE);
 
 		/* Now that we know the length, get the whole thing */
-		bigbuffer = kmalloc(length, GFP_KERNEL);
+		bigbuffer = kmalloc(length, GFP_KERNEL | __GFP_IUBIK);
 		if (!bigbuffer) {
 			result = -ENOMEM;
 			goto err;
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index ec8e003f5941..40febc5d5c08 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -633,7 +633,7 @@ static char *usb_devnode(struct device *dev,
 	struct usb_device *usb_dev;
 
 	usb_dev = to_usb_device(dev);
-	return kasprintf(GFP_KERNEL, "bus/usb/%03d/%03d",
+	return kasprintf(GFP_KERNEL | __GFP_IUBIK, "bus/usb/%03d/%03d",
 			 usb_dev->bus->busnum, usb_dev->devnum);
 }
 
diff --git a/drivers/usb/gadget/function/u_ether.c b/drivers/usb/gadget/function/u_ether.c
index ba7284a1c0d6..d18de3a7bbd3 100644
--- a/drivers/usb/gadget/function/u_ether.c
+++ b/drivers/usb/gadget/function/u_ether.c
@@ -1044,7 +1044,7 @@ int gether_set_ifname(struct net_device *net, const char *name, int len)
 	if (!p || p[1] != 'd' || strchr(p + 2, '%'))
 		return -EINVAL;
 
-	strncpy(net->name, tmp, sizeof(net->name));
+	strncpy(net->name, tmp, sizeof__net_device__name);
 	dev->ifname_set = true;
 
 	return 0;
diff --git a/drivers/video/fbdev/core/fbcon.c b/drivers/video/fbdev/core/fbcon.c
index b6712655ec1f..059831b4bf94 100644
--- a/drivers/video/fbdev/core/fbcon.c
+++ b/drivers/video/fbdev/core/fbcon.c
@@ -2516,7 +2516,7 @@ static int fbcon_set_font(struct vc_data *vc, struct console_font *font,
 
 	size = CALC_FONTSZ(h, pitch, charcount);
 
-	new_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);
+	new_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER | __GFP_IUBIK);
 
 	if (!new_data)
 		return -ENOMEM;
diff --git a/drivers/video/fbdev/core/softcursor.c b/drivers/video/fbdev/core/softcursor.c
index 29e5b21cf373..c6251ddfd811 100644
--- a/drivers/video/fbdev/core/softcursor.c
+++ b/drivers/video/fbdev/core/softcursor.c
@@ -38,7 +38,7 @@ int soft_cursor(struct fb_info *info, struct fb_cursor *cursor)
 		kfree(ops->cursor_src);
 		ops->cursor_size = dsize + sizeof(struct fb_image);
 
-		ops->cursor_src = kmalloc(ops->cursor_size, GFP_ATOMIC);
+		ops->cursor_src = kmalloc(ops->cursor_size, GFP_ATOMIC | __GFP_IUBIK);
 		if (!ops->cursor_src) {
 			ops->cursor_size = 0;
 			return -ENOMEM;
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index 30379c33ad20..e11c5dc87539 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -289,7 +289,7 @@ create_elf_tables(struct linux_binprm *bprm, const struct elfhdr *exec,
 #undef NEW_AUX_ENT
 	/* AT_NULL is zero; clear the rest too */
 	memset(elf_info, 0, (char *)mm->saved_auxv +
-			sizeof(mm->saved_auxv) - (char *)elf_info);
+			sizeof__mm_struct__saved_auxv - (char *)elf_info);
 
 	/* And advance past the AT_NULL entry.  */
 	elf_info += 2;
@@ -882,7 +882,7 @@ static int load_elf_binary(struct linux_binprm *bprm)
 			goto out_free_ph;
 
 		retval = -ENOMEM;
-		elf_interpreter = kmalloc(elf_ppnt->p_filesz, GFP_KERNEL);
+		elf_interpreter = kmalloc(elf_ppnt->p_filesz, GFP_KERNEL | __GFP_IUBIK);
 		if (!elf_interpreter)
 			goto out_free_ph;
 
diff --git a/fs/binfmt_misc.c b/fs/binfmt_misc.c
index 7c01973da6c8..f96e5a92456e 100644
--- a/fs/binfmt_misc.c
+++ b/fs/binfmt_misc.c
@@ -60,6 +60,7 @@ typedef struct {
 	char *name;
 	struct dentry *dentry;
 	struct file *interp_file;
+	char * buf;
 } Node;
 
 static DEFINE_RWLOCK(entries_lock);
@@ -274,7 +275,7 @@ static char *check_special_flags(char *sfs, Node *e)
 static Node *create_entry(const char __user *buffer, size_t count)
 {
 	Node *e;
-	int memsize, err;
+	int err;
 	char *buf, *p;
 	char del;
 
@@ -286,14 +287,18 @@ static Node *create_entry(const char __user *buffer, size_t count)
 		goto out;
 
 	err = -ENOMEM;
-	memsize = sizeof(Node) + count + 8;
-	e = kmalloc(memsize, GFP_KERNEL);
+	e = kmalloc(sizeof(Node), GFP_KERNEL);
 	if (!e)
 		goto out;
-
-	p = buf = (char *)e + sizeof(Node);
-
 	memset(e, 0, sizeof(Node));
+	
+	e->buf = kmalloc(count + 8, GFP_KERNEL_IUBIK);
+	if (!e->buf) {
+		kfree(e);
+		goto out;
+	}
+	p = buf = e->buf;
+
 	if (copy_from_user(buf, buffer, count))
 		goto efault;
 
@@ -465,9 +470,11 @@ static Node *create_entry(const char __user *buffer, size_t count)
 	return ERR_PTR(err);
 
 efault:
+	kfree(e->buf);
 	kfree(e);
 	return ERR_PTR(-EFAULT);
 einval:
+	kfree(e->buf);
 	kfree(e);
 	return ERR_PTR(-EINVAL);
 }
@@ -561,6 +568,7 @@ static void bm_evict_inode(struct inode *inode)
 		filp_close(e->interp_file, NULL);
 
 	clear_inode(inode);
+	kfree(e->buf);
 	kfree(e);
 }
 
@@ -661,6 +669,7 @@ static ssize_t bm_register_write(struct file *file, const char __user *buffer,
 		if (IS_ERR(f)) {
 			pr_notice("register: failed to install interpreter file %s\n",
 				 e->interpreter);
+			kfree(e->buf);
 			kfree(e);
 			return PTR_ERR(f);
 		}
@@ -708,6 +717,7 @@ static ssize_t bm_register_write(struct file *file, const char __user *buffer,
 	if (err) {
 		if (f)
 			filp_close(f, NULL);
+		kfree(e->buf);
 		kfree(e);
 		return err;
 	}
diff --git a/fs/binfmt_script.c b/fs/binfmt_script.c
index 1b6625e95958..129ffbd711ee 100644
--- a/fs/binfmt_script.c
+++ b/fs/binfmt_script.c
@@ -55,8 +55,8 @@ static int load_script(struct linux_binprm *bprm)
 	 * arguments is fine: the interpreter can re-read the script to
 	 * parse them on its own.
 	 */
-	buf_end = bprm->buf + sizeof(bprm->buf) - 1;
-	i_end = strnchr(bprm->buf, sizeof(bprm->buf), '\n');
+	buf_end = bprm->buf + sizeof__linux_binprm__buf - 1;
+	i_end = strnchr(bprm->buf, sizeof__linux_binprm__buf, '\n');
 	if (!i_end) {
 		i_end = next_non_spacetab(bprm->buf + 2, buf_end);
 		if (!i_end)
diff --git a/fs/dcache.c b/fs/dcache.c
index 2225920518ba..1191b54ae8f0 100644
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -35,6 +35,9 @@
 #include "internal.h"
 #include "mount.h"
 
+#include <asm/iubik-pac.h>
+#include <asm/pointer_auth.h>
+
 /*
  * Usage:
  * dcache->d_inode->i_lock protects:
@@ -253,17 +256,36 @@ static inline int dentry_cmp(const struct dentry *dentry, const unsigned char *c
 	return dentry_string_cmp(cs, ct, tcount);
 }
 
+struct user_external_name {
+	struct external_name *e_name;
+#if !defined(CONFIG_IUBIK_BACKREF_PAC)
+	void *padding; // pad to align the size for MTE to 16
+#endif
+	unsigned char name[];
+};
+
 struct external_name {
 	union {
 		atomic_t count;
 		struct rcu_head head;
 	} u;
-	unsigned char name[];
+	struct user_external_name *ue_name;
 };
 
 static inline struct external_name *external_name(struct dentry *dentry)
 {
-	return container_of(dentry->d_name.name, struct external_name, name[0]);
+	struct user_external_name *ue_name;
+	struct external_name *p;
+	
+	ue_name = container_of(dentry->d_name.name, struct user_external_name, name[0]);
+#ifdef CONFIG_IUBIK_BACKREF_PAC
+	p = iubik_pac_auth(ue_name->e_name, &ue_name->e_name);
+#else
+	ue_name = iubik_tag_set_domk(ue_name);
+	p = ue_name->e_name;
+#endif
+	
+	return p;
 }
 
 static void __d_free(struct rcu_head *head)
@@ -276,7 +298,12 @@ static void __d_free(struct rcu_head *head)
 static void __d_free_external(struct rcu_head *head)
 {
 	struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);
-	kfree(external_name(dentry));
+	struct external_name *e_name = external_name(dentry);
+#if !defined(CONFIG_IUBIK_BACKREF_PAC)
+        iubik_set_mem_tag_range_domu(e_name->ue_name, 16);
+#endif
+	kfree(e_name->ue_name);
+	kfree(e_name);
 	kmem_cache_free(dentry_cache, dentry);
 }
 
@@ -300,13 +327,32 @@ void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry
 }
 EXPORT_SYMBOL(take_dentry_name_snapshot);
 
+static void put_extname_rcu(struct rcu_head *head)
+{
+	struct external_name *name = container_of(head, struct external_name, u.head);
+#if !defined(CONFIG_IUBIK_BACKREF_PAC)
+        iubik_set_mem_tag_range_domu(name->ue_name, 16);
+#endif
+	kfree(name->ue_name);
+	kfree(name);
+}
+
 void release_dentry_name_snapshot(struct name_snapshot *name)
 {
 	if (unlikely(name->name.name != name->inline_name)) {
 		struct external_name *p;
-		p = container_of(name->name.name, struct external_name, name[0]);
+		struct user_external_name *ue_name;
+		
+		ue_name = container_of(name->name.name, struct user_external_name, name[0]);
+#ifdef CONFIG_IUBIK_BACKREF_PAC
+		p = iubik_pac_auth(ue_name->e_name, &ue_name->e_name);
+#else
+                ue_name = iubik_tag_set_domk(ue_name);
+		p = ue_name->e_name;
+#endif
+		
 		if (unlikely(atomic_dec_and_test(&p->u.count)))
-			kfree_rcu(p, u.head);
+			call_rcu(&p->u.head, put_extname_rcu);
 	}
 }
 EXPORT_SYMBOL(release_dentry_name_snapshot);
@@ -1734,7 +1780,6 @@ EXPORT_SYMBOL(d_invalidate);
  * available. On a success the dentry is returned. The name passed in is
  * copied and the copy passed in may be reused after this call.
  */
- 
 static struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)
 {
 	struct dentry *dentry;
@@ -1756,16 +1801,31 @@ static struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)
 		name = &slash_name;
 		dname = dentry->d_iname;
 	} else if (name->len > DNAME_INLINE_LEN-1) {
-		size_t size = offsetof(struct external_name, name[1]);
-		struct external_name *p = kmalloc(size + name->len,
+		size_t size;
+		struct external_name *p = kmalloc(sizeof(struct external_name),
 						  GFP_KERNEL_ACCOUNT |
 						  __GFP_RECLAIMABLE);
+		
 		if (!p) {
 			kmem_cache_free(dentry_cache, dentry); 
 			return NULL;
 		}
+
+		size = offsetof(struct user_external_name, name[1]);
+		p->ue_name = kmalloc(size + name->len, GFP_KERNEL_ACCOUNT | __GFP_IUBIK);
+		if (!p->ue_name) {
+			kfree(p);
+			kmem_cache_free(dentry_cache, dentry); 
+			return NULL;
+		}
+#ifdef CONFIG_IUBIK_BACKREF_PAC
+		p->ue_name->e_name = iubik_pac_sign(p, &p->ue_name->e_name);
+#else
+		p->ue_name->e_name = p;
+		iubik_set_mem_tag_range_domk(p->ue_name, 16);
+#endif
 		atomic_set(&p->u.count, 1);
-		dname = p->name;
+		dname = p->ue_name->name;
 	} else  {
 		dname = dentry->d_iname;
 	}	
@@ -1797,8 +1857,14 @@ static struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)
 	if (dentry->d_op && dentry->d_op->d_init) {
 		err = dentry->d_op->d_init(dentry);
 		if (err) {
-			if (dname_external(dentry))
-				kfree(external_name(dentry));
+			if (dname_external(dentry)) {
+				struct external_name *e_name = external_name(dentry);
+#if !defined(CONFIG_IUBIK_BACKREF_PAC)
+                                iubik_set_mem_tag_range_domu(e_name->ue_name, 16);
+#endif
+				kfree(e_name->ue_name);
+				kfree(e_name);
+			}
 			kmem_cache_free(dentry_cache, dentry);
 			return NULL;
 		}
@@ -2841,7 +2907,7 @@ static void copy_name(struct dentry *dentry, struct dentry *target)
 		dentry->d_name.hash_len = target->d_name.hash_len;
 	}
 	if (old_name && likely(atomic_dec_and_test(&old_name->u.count)))
-		kfree_rcu(old_name, u.head);
+		call_rcu(&old_name->u.head, put_extname_rcu);
 }
 
 /*
@@ -3246,6 +3312,9 @@ static void __init dcache_init(void)
 struct kmem_cache *names_cachep __read_mostly;
 EXPORT_SYMBOL(names_cachep);
 
+struct kmem_cache *inames_cachep __read_mostly;
+EXPORT_SYMBOL(inames_cachep);
+
 void __init vfs_caches_init_early(void)
 {
 	int i;
@@ -3259,9 +3328,10 @@ void __init vfs_caches_init_early(void)
 
 void __init vfs_caches_init(void)
 {
-	names_cachep = kmem_cache_create_usercopy("names_cache", PATH_MAX, 0,
-			SLAB_HWCACHE_ALIGN|SLAB_PANIC, 0, PATH_MAX, NULL);
-
+	names_cachep = kmem_cache_create("names_cache", sizeof(struct filename), 0,
+			SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
+	inames_cachep = kmem_cache_create_usercopy("inames_cache", PATH_MAX, 0,
+			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_IUBIK, 0, PATH_MAX, NULL);
 	dcache_init();
 	inode_init();
 	files_init();
diff --git a/fs/efivarfs/file.c b/fs/efivarfs/file.c
index d57ee15874f9..914c7a53ea4a 100644
--- a/fs/efivarfs/file.c
+++ b/fs/efivarfs/file.c
@@ -87,7 +87,7 @@ static ssize_t efivarfs_file_read(struct file *file, char __user *userbuf,
 	else if (err)
 		return err;
 
-	data = kmalloc(datasize + sizeof(attributes), GFP_KERNEL);
+	data = kmalloc(datasize + sizeof(attributes), GFP_KERNEL | __GFP_IUBIK);
 
 	if (!data)
 		return -ENOMEM;
diff --git a/fs/exec.c b/fs/exec.c
index 3ce0c7480335..abfbcd0a297d 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1511,6 +1511,7 @@ static void free_bprm(struct linux_binprm *bprm)
 	if (bprm->interp != bprm->filename)
 		kfree(bprm->interp);
 	kfree(bprm->fdpath);
+	kfree(bprm->buf);
 	kfree(bprm);
 }
 
@@ -1521,6 +1522,12 @@ static struct linux_binprm *alloc_bprm(int fd, struct filename *filename)
 	if (!bprm)
 		goto out;
 
+	bprm->buf = kzalloc(sizeof__linux_binprm__buf, GFP_KERNEL_IUBIK);
+	if (!bprm->buf) {
+		kfree(bprm);
+		goto out;
+	}
+
 	if (fd == AT_FDCWD || filename->name[0] == '/') {
 		bprm->filename = filename->name;
 	} else {
diff --git a/fs/ext2/ialloc.c b/fs/ext2/ialloc.c
index df14e750e9fe..785561d22669 100644
--- a/fs/ext2/ialloc.c
+++ b/fs/ext2/ialloc.c
@@ -556,7 +556,7 @@ struct inode *ext2_new_inode(struct inode *dir, umode_t mode,
 	inode->i_ino = ino;
 	inode->i_blocks = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
-	memset(ei->i_data, 0, sizeof(ei->i_data));
+	memset(ei->i_data, 0, sizeof__ei__i_data);
 	ei->i_flags =
 		ext2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);
 	ei->i_faddr = 0;
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index 333fa62661d5..85a3a4a35037 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -1504,7 +1504,7 @@ struct inode *ext2_iget (struct super_block *sb, unsigned long ino)
 			inode->i_link = (char *)ei->i_data;
 			inode->i_op = &ext2_fast_symlink_inode_operations;
 			nd_terminate_link(ei->i_data, inode->i_size,
-				sizeof(ei->i_data) - 1);
+				sizeof__ei__i_data - 1);
 		} else {
 			inode->i_op = &ext2_symlink_inode_operations;
 			inode_nohighmem(inode);
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index e1a5ec7362ad..2e8bb2d38bd3 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1009,7 +1009,8 @@ enum {
  * fourth extended file system inode data in memory
  */
 struct ext4_inode_info {
-	__le32	i_data[15];	/* unconverted */
+#define sizeof__ei__i_data (15 * sizeof(__le32))
+	__le32	*i_data;	/* unconverted */
 	__u32	i_dtime;
 	ext4_fsblk_t	i_file_acl;
 
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index 745d781da891..35148af5cee4 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -1256,7 +1256,7 @@ struct inode *__ext4_new_inode(struct user_namespace *mnt_userns,
 	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
 	ei->i_crtime = inode->i_mtime;
 
-	memset(ei->i_data, 0, sizeof(ei->i_data));
+	memset(ei->i_data, 0, sizeof__ei__i_data);
 	ei->i_dir_start_lookup = 0;
 	ei->i_disksize = 0;
 
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 4f37fec95c2f..8d79bbe17d90 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -4894,7 +4894,7 @@ struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,
 			inode->i_link = (char *)ei->i_data;
 			inode->i_op = &ext4_fast_symlink_inode_operations;
 			nd_terminate_link(ei->i_data, inode->i_size,
-				sizeof(ei->i_data) - 1);
+				sizeof__ei__i_data - 1);
 		} else {
 			inode->i_op = &ext4_symlink_inode_operations;
 			ext4_set_aops(inode);
diff --git a/fs/ext4/ioctl.c b/fs/ext4/ioctl.c
index 18002b0a908c..c9113408eed0 100644
--- a/fs/ext4/ioctl.c
+++ b/fs/ext4/ioctl.c
@@ -190,7 +190,7 @@ static long swap_inode_boot_loader(struct super_block *sb,
 			ext4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);
 			ext4_ext_tree_init(handle, inode_bl);
 		} else
-			memset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));
+			memset(ei_bl->i_data, 0, sizeof__ei__i_data);
 	}
 
 	err = dquot_initialize(inode);
diff --git a/fs/ext4/migrate.c b/fs/ext4/migrate.c
index b0ea646454ac..c4f8d7a1d386 100644
--- a/fs/ext4/migrate.c
+++ b/fs/ext4/migrate.c
@@ -321,7 +321,7 @@ static int ext4_ext_swap_inode_data(handle_t *handle, struct inode *inode,
 	 * Now copy the i_data across
 	 */
 	ext4_set_inode_flag(inode, EXT4_INODE_EXTENTS);
-	memcpy(ei->i_data, tmp_ei->i_data, sizeof(ei->i_data));
+	memcpy(ei->i_data, tmp_ei->i_data, sizeof__ei__i_data);
 
 	/*
 	 * Update i_blocks with the new blocks that got
@@ -656,7 +656,7 @@ int ext4_ind_migrate(struct inode *inode)
 	}
 
 	ext4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);
-	memset(ei->i_data, 0, sizeof(ei->i_data));
+	memset(ei->i_data, 0, sizeof__ei__i_data);
 	for (i = start; i <= end; i++)
 		ei->i_data[i] = cpu_to_le32(blk++);
 	ret2 = ext4_mark_inode_dirty(handle, inode);
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 4a8bbd581fa1..4bf221535c5c 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1288,6 +1288,12 @@ static struct inode *ext4_alloc_inode(struct super_block *sb)
 	ei = kmem_cache_alloc(ext4_inode_cachep, GFP_NOFS);
 	if (!ei)
 		return NULL;
+	
+	ei->i_data = kmalloc(sizeof__ei__i_data, GFP_NOFS | __GFP_IUBIK);
+	if (!ei->i_data) {
+		kmem_cache_free(ext4_inode_cachep, ei);
+		return NULL;
+	}
 
 	inode_set_iversion(&ei->vfs_inode, 1);
 	ei->i_flags = 0;
@@ -1338,6 +1344,7 @@ static void ext4_free_in_core_inode(struct inode *inode)
 		pr_warn("%s: inode %ld still in fc list",
 			__func__, inode->i_ino);
 	}
+	kfree(EXT4_I(inode)->i_data);
 	kmem_cache_free(ext4_inode_cachep, EXT4_I(inode));
 }
 
@@ -1373,12 +1380,10 @@ static void init_once(void *foo)
 
 static int __init init_inodecache(void)
 {
-	ext4_inode_cachep = kmem_cache_create_usercopy("ext4_inode_cache",
+	ext4_inode_cachep = kmem_cache_create("ext4_inode_cache",
 				sizeof(struct ext4_inode_info), 0,
 				(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|
 					SLAB_ACCOUNT),
-				offsetof(struct ext4_inode_info, i_data),
-				sizeof_field(struct ext4_inode_info, i_data),
 				init_once);
 	if (ext4_inode_cachep == NULL)
 		return -ENOMEM;
diff --git a/fs/fhandle.c b/fs/fhandle.c
index 6630c69c23a2..0120e62aa995 100644
--- a/fs/fhandle.c
+++ b/fs/fhandle.c
@@ -37,11 +37,17 @@ static long do_sys_name_to_handle(struct path *path,
 	if (f_handle.handle_bytes > MAX_HANDLE_SZ)
 		return -EINVAL;
 
-	handle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,
+	handle = kmalloc(sizeof(struct file_handle),
 			 GFP_KERNEL);
 	if (!handle)
 		return -ENOMEM;
 
+	handle->f_handle = kmalloc(f_handle.handle_bytes, GFP_KERNEL_IUBIK);
+	if (!handle->f_handle) {
+		kfree(handle);
+		return -ENOMEM;
+	}
+
 	/* convert handle size to multiple of sizeof(u32) */
 	handle_dwords = f_handle.handle_bytes >> 2;
 
@@ -73,6 +79,7 @@ static long do_sys_name_to_handle(struct path *path,
 	    copy_to_user(ufh, handle,
 			 sizeof(struct file_handle) + handle_bytes))
 		retval = -EFAULT;
+	kfree(handle->f_handle);
 	kfree(handle);
 	return retval;
 }
@@ -189,23 +196,32 @@ static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,
 		retval = -EINVAL;
 		goto out_err;
 	}
-	handle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,
+	handle = kmalloc(sizeof(struct file_handle),
 			 GFP_KERNEL);
 	if (!handle) {
 		retval = -ENOMEM;
 		goto out_err;
 	}
+	
+	handle->f_handle = kmalloc(f_handle.handle_bytes, GFP_KERNEL_IUBIK);
+	if (!handle->f_handle) {
+		retval = -ENOMEM;
+		goto out_handle;
+	}
+
 	/* copy the full handle */
 	*handle = f_handle;
 	if (copy_from_user(&handle->f_handle,
 			   &ufh->f_handle,
 			   f_handle.handle_bytes)) {
 		retval = -EFAULT;
-		goto out_handle;
+		goto out_fhandle;
 	}
 
 	retval = do_handle_to_path(mountdirfd, handle, path);
 
+out_handle:
+	kfree(handle->f_handle)
 out_handle:
 	kfree(handle);
 out_err:
diff --git a/fs/fs_context.c b/fs/fs_context.c
index 851214d1d013..8fad20311f85 100644
--- a/fs/fs_context.c
+++ b/fs/fs_context.c
@@ -175,7 +175,7 @@ int vfs_parse_fs_string(struct fs_context *fc, const char *key,
 	};
 
 	if (value) {
-		param.string = kmemdup_nul(value, v_size, GFP_KERNEL);
+		param.string = kmemdup_nul(value, v_size, GFP_KERNEL | __GFP_IUBIK);
 		if (!param.string)
 			return -ENOMEM;
 		param.type = fs_value_is_string;
@@ -556,7 +556,7 @@ static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)
 		return invalf(fc, "VFS: Legacy: Option '%s' contained comma",
 			      param->key);
 	if (!ctx->legacy_data) {
-		ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);
+		ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL | __GFP_IUBIK);
 		if (!ctx->legacy_data)
 			return -ENOMEM;
 	}
diff --git a/fs/kernfs/dir.c b/fs/kernfs/dir.c
index 6a1cb2a182b6..0b625670ca15 100644
--- a/fs/kernfs/dir.c
+++ b/fs/kernfs/dir.c
@@ -586,7 +586,7 @@ static struct kernfs_node *__kernfs_new_node(struct kernfs_root *root,
 	u32 id_highbits;
 	int ret;
 
-	name = kstrdup_const(name, GFP_KERNEL);
+	name = kstrdup_const(name, GFP_KERNEL | __GFP_IUBIK);
 	if (!name)
 		return NULL;
 
@@ -1600,7 +1600,7 @@ int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,
 	/* rename kernfs_node */
 	if (strcmp(kn->name, new_name) != 0) {
 		error = -ENOMEM;
-		new_name = kstrdup_const(new_name, GFP_KERNEL);
+		new_name = kstrdup_const(new_name, GFP_KERNEL | __GFP_IUBIK);
 		if (!new_name)
 			goto out;
 	} else {
diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 60e2a86c535e..25e416c2678b 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -192,7 +192,7 @@ static ssize_t kernfs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 	if (buf)
 		mutex_lock(&of->prealloc_mutex);
 	else
-		buf = kmalloc(len, GFP_KERNEL);
+		buf = kmalloc(len, GFP_KERNEL | __GFP_IUBIK);
 	if (!buf)
 		return -ENOMEM;
 
@@ -270,7 +270,7 @@ static ssize_t kernfs_fop_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 	if (buf)
 		mutex_lock(&of->prealloc_mutex);
 	else
-		buf = kmalloc(len + 1, GFP_KERNEL);
+		buf = kmalloc(len + 1, GFP_KERNEL | __GFP_IUBIK);
 	if (!buf)
 		return -ENOMEM;
 
diff --git a/fs/kernfs/symlink.c b/fs/kernfs/symlink.c
index c8f8e41b8411..19feb1cc7d53 100644
--- a/fs/kernfs/symlink.c
+++ b/fs/kernfs/symlink.c
@@ -132,7 +132,7 @@ static const char *kernfs_iop_get_link(struct dentry *dentry,
 
 	if (!dentry)
 		return ERR_PTR(-ECHILD);
-	body = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	body = kzalloc(PAGE_SIZE, GFP_KERNEL | __GFP_IUBIK);
 	if (!body)
 		return ERR_PTR(-ENOMEM);
 	error = kernfs_getlink(inode, body);
diff --git a/fs/ksmbd/smb2pdu.c b/fs/ksmbd/smb2pdu.c
index 656c627d1bdf..6584cd67eafe 100644
--- a/fs/ksmbd/smb2pdu.c
+++ b/fs/ksmbd/smb2pdu.c
@@ -7407,7 +7407,7 @@ static int fsctl_query_iface_info_ioctl(struct ksmbd_conn *conn,
 				if (ifa->flags & (IFA_F_TENTATIVE |
 							IFA_F_DEPRECATED))
 					continue;
-				memcpy(ipv6_addr, ifa->addr.s6_addr, 16);
+				memcpy(ipv6_addr, ifa->addr->s6_addr, 16);
 				break;
 			}
 			sockaddr_storage->addr6.ScopeId = 0;
diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index b632be3ad57b..d0ce08b5cf16 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -337,9 +337,9 @@ static int lockd_inet6addr_event(struct notifier_block *this,
 		goto out;
 
 	if (nlmsvc_rqst) {
-		dprintk("lockd_inet6addr_event: removed %pI6\n", &ifa->addr);
+		dprintk("lockd_inet6addr_event: removed %pI6\n", ifa->addr);
 		sin6.sin6_family = AF_INET6;
-		sin6.sin6_addr = ifa->addr;
+		sin6.sin6_addr = *ifa->addr;
 		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
 			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
 		svc_age_temp_xprts_now(nlmsvc_rqst->rq_server,
diff --git a/fs/namei.c b/fs/namei.c
index 8cbbc0c16789..f900dab04e55 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -122,8 +122,6 @@
  * PATH_MAX includes the nul terminator --RR.
  */
 
-#define EMBEDDED_NAME_MAX	(PATH_MAX - offsetof(struct filename, iname))
-
 struct filename *
 getname_flags(const char __user *filename, int flags, int *empty)
 {
@@ -135,10 +133,16 @@ getname_flags(const char __user *filename, int flags, int *empty)
 	if (result)
 		return result;
 
-	result = __getname();
+	result = __getfilename();
 	if (unlikely(!result))
 		return ERR_PTR(-ENOMEM);
 
+	result->iname = __getname();
+	if (unlikely(!result->iname)) {
+		__putfilename(result);
+		return ERR_PTR(-ENOMEM);
+	}
+
 	/*
 	 * First, try to embed the struct filename inside the names_cache
 	 * allocation
@@ -146,44 +150,16 @@ getname_flags(const char __user *filename, int flags, int *empty)
 	kname = (char *)result->iname;
 	result->name = kname;
 
-	len = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);
+	len = strncpy_from_user(kname, filename, PATH_MAX);
 	if (unlikely(len < 0)) {
-		__putname(result);
+		__putname(result->iname);
+		__putfilename(result);
 		return ERR_PTR(len);
 	}
-
-	/*
-	 * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a
-	 * separate struct filename so we can dedicate the entire
-	 * names_cache allocation for the pathname, and re-do the copy from
-	 * userland.
-	 */
-	if (unlikely(len == EMBEDDED_NAME_MAX)) {
-		const size_t size = offsetof(struct filename, iname[1]);
-		kname = (char *)result;
-
-		/*
-		 * size is chosen that way we to guarantee that
-		 * result->iname[0] is within the same object and that
-		 * kname can't be equal to result->iname, no matter what.
-		 */
-		result = kzalloc(size, GFP_KERNEL);
-		if (unlikely(!result)) {
-			__putname(kname);
-			return ERR_PTR(-ENOMEM);
-		}
-		result->name = kname;
-		len = strncpy_from_user(kname, filename, PATH_MAX);
-		if (unlikely(len < 0)) {
-			__putname(kname);
-			kfree(result);
-			return ERR_PTR(len);
-		}
-		if (unlikely(len == PATH_MAX)) {
-			__putname(kname);
-			kfree(result);
-			return ERR_PTR(-ENAMETOOLONG);
-		}
+	if (unlikely(len == PATH_MAX)) {
+		__putname(result->iname);
+		__putfilename(result);
+		return ERR_PTR(-ENAMETOOLONG);
 	}
 
 	result->refcnt = 1;
@@ -223,25 +199,19 @@ getname_kernel(const char * filename)
 	struct filename *result;
 	int len = strlen(filename) + 1;
 
-	result = __getname();
+	result = __getfilename();
 	if (unlikely(!result))
 		return ERR_PTR(-ENOMEM);
 
-	if (len <= EMBEDDED_NAME_MAX) {
-		result->name = (char *)result->iname;
-	} else if (len <= PATH_MAX) {
-		const size_t size = offsetof(struct filename, iname[1]);
-		struct filename *tmp;
-
-		tmp = kmalloc(size, GFP_KERNEL);
-		if (unlikely(!tmp)) {
-			__putname(result);
+	if (len <= PATH_MAX) {
+		result->iname = __getname();
+		if (unlikely(!result->iname)) {
+			__putfilename(result);
 			return ERR_PTR(-ENOMEM);
 		}
-		tmp->name = (char *)result;
-		result = tmp;
+		result->name = (char *)result->iname;
 	} else {
-		__putname(result);
+		__putfilename(result);
 		return ERR_PTR(-ENAMETOOLONG);
 	}
 	memcpy((char *)result->name, filename, len);
@@ -263,11 +233,8 @@ void putname(struct filename *name)
 	if (--name->refcnt > 0)
 		return;
 
-	if (name->name != name->iname) {
-		__putname(name->name);
-		kfree(name);
-	} else
-		__putname(name);
+	__putname(name->iname);
+	__putfilename(name);
 }
 
 /**
diff --git a/fs/namespace.c b/fs/namespace.c
index 709ea097090f..1ddd6c153743 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -205,7 +205,7 @@ static struct mount *alloc_vfsmnt(const char *name)
 
 		if (name) {
 			mnt->mnt_devname = kstrdup_const(name,
-							 GFP_KERNEL_ACCOUNT);
+							 GFP_KERNEL_ACCOUNT | __GFP_IUBIK);
 			if (!mnt->mnt_devname)
 				goto out_free_id;
 		}
@@ -3199,7 +3199,7 @@ static void *copy_mount_options(const void __user * data)
 	if (!data)
 		return NULL;
 
-	copy = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	copy = kmalloc(PAGE_SIZE, GFP_KERNEL | __GFP_IUBIK);
 	if (!copy)
 		return ERR_PTR(-ENOMEM);
 
diff --git a/fs/nfsd/nfssvc.c b/fs/nfsd/nfssvc.c
index 373695cc62a7..7f76f7712d94 100644
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@ -480,9 +480,9 @@ static int nfsd_inet6addr_event(struct notifier_block *this,
 		goto out;
 
 	if (nn->nfsd_serv) {
-		dprintk("nfsd_inet6addr_event: removed %pI6\n", &ifa->addr);
+		dprintk("nfsd_inet6addr_event: removed %pI6\n", ifa->addr);
 		sin6.sin6_family = AF_INET6;
-		sin6.sin6_addr = ifa->addr;
+		sin6.sin6_addr = *ifa->addr;
 		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
 			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
 		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
diff --git a/fs/notify/inotify/inotify.h b/fs/notify/inotify/inotify.h
index 8f00151eb731..9db7da824482 100644
--- a/fs/notify/inotify/inotify.h
+++ b/fs/notify/inotify/inotify.h
@@ -9,7 +9,7 @@ struct inotify_event_info {
 	int wd;
 	u32 sync_cookie;
 	int name_len;
-	char name[];
+	char *name;
 };
 
 struct inotify_inode_mark {
diff --git a/fs/notify/inotify/inotify_fsnotify.c b/fs/notify/inotify/inotify_fsnotify.c
index b0530f75b274..bc69652e0b8e 100644
--- a/fs/notify/inotify/inotify_fsnotify.c
+++ b/fs/notify/inotify/inotify_fsnotify.c
@@ -66,13 +66,10 @@ int inotify_handle_inode_event(struct fsnotify_mark *inode_mark, u32 mask,
 	struct fsnotify_group *group = inode_mark->group;
 	int ret;
 	int len = 0, wd;
-	int alloc_len = sizeof(struct inotify_event_info);
 	struct mem_cgroup *old_memcg;
 
-	if (name) {
+	if (name)
 		len = name->len;
-		alloc_len += len + 1;
-	}
 
 	pr_debug("%s: group=%p mark=%p mask=%x\n", __func__, group, inode_mark,
 		 mask);
@@ -93,7 +90,8 @@ int inotify_handle_inode_event(struct fsnotify_mark *inode_mark, u32 mask,
 	 * security repercussion.
 	 */
 	old_memcg = set_active_memcg(group->memcg);
-	event = kmalloc(alloc_len, GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL);
+	event = kmalloc(sizeof(struct inotify_event_info), GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL);
+	event->name = kmalloc(len+1, GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL | __GFP_IUBIK);
 	set_active_memcg(old_memcg);
 
 	if (unlikely(!event)) {
@@ -104,6 +102,13 @@ int inotify_handle_inode_event(struct fsnotify_mark *inode_mark, u32 mask,
 		fsnotify_queue_overflow(group);
 		return -ENOMEM;
 	}
+	
+	if (unlikely(!event->name)) {
+		kfree(event);
+		// see above comment
+		fsnotify_queue_overflow(group);
+		return -ENOMEM;
+	}
 
 	/*
 	 * We now report FS_ISDIR flag with MOVE_SELF and DELETE_SELF events
@@ -186,6 +191,7 @@ static void inotify_free_group_priv(struct fsnotify_group *group)
 
 static void inotify_free_event(struct fsnotify_event *fsn_event)
 {
+	kfree(INOTIFY_E(fsn_event)->name);
 	kfree(INOTIFY_E(fsn_event));
 }
 
diff --git a/fs/proc/generic.c b/fs/proc/generic.c
index d32f69aaaa36..0ea404b80746 100644
--- a/fs/proc/generic.c
+++ b/fs/proc/generic.c
@@ -465,7 +465,7 @@ struct proc_dir_entry *proc_symlink(const char *name,
 			  (S_IFLNK | S_IRUGO | S_IWUGO | S_IXUGO),1);
 
 	if (ent) {
-		ent->data = kmalloc((ent->size=strlen(dest))+1, GFP_KERNEL);
+		ent->data = kmalloc((ent->size=strlen(dest))+1, GFP_KERNEL | __GFP_IUBIK);
 		if (ent->data) {
 			strcpy((char*)ent->data,dest);
 			ent->proc_iops = &proc_link_inode_operations;
diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c
index 0b7a00ed6c49..9ca04fe6fd11 100644
--- a/fs/proc/proc_sysctl.c
+++ b/fs/proc/proc_sysctl.c
@@ -567,7 +567,7 @@ static ssize_t proc_sys_call_handler(struct kiocb *iocb, struct iov_iter *iter,
 	error = -ENOMEM;
 	if (count >= KMALLOC_MAX_SIZE)
 		goto out;
-	kbuf = kvzalloc(count + 1, GFP_KERNEL);
+	kbuf = kvzalloc(count + 1, GFP_KERNEL | __GFP_IUBIK);
 	if (!kbuf)
 		goto out;
 
diff --git a/fs/proc/self.c b/fs/proc/self.c
index 72cd69bcaf4a..5aa00a1e9029 100644
--- a/fs/proc/self.c
+++ b/fs/proc/self.c
@@ -19,7 +19,7 @@ static const char *proc_self_get_link(struct dentry *dentry,
 	if (!tgid)
 		return ERR_PTR(-ENOENT);
 	/* max length of unsigned int in decimal + NULL term */
-	name = kmalloc(10 + 1, dentry ? GFP_KERNEL : GFP_ATOMIC);
+	name = kmalloc(10 + 1, dentry ? GFP_KERNEL | __GFP_IUBIK : GFP_ATOMIC | __GFP_IUBIK);
 	if (unlikely(!name))
 		return dentry ? ERR_PTR(-ENOMEM) : ERR_PTR(-ECHILD);
 	sprintf(name, "%u", tgid);
diff --git a/fs/select.c b/fs/select.c
index 5edffee1162c..44c8f5b9d989 100644
--- a/fs/select.c
+++ b/fs/select.c
@@ -658,7 +658,7 @@ int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,
 			goto out_nofds;
 
 		alloc_size = 6 * size;
-		bits = kvmalloc(alloc_size, GFP_KERNEL);
+		bits = kvmalloc(alloc_size, GFP_KERNEL | __GFP_IUBIK);
 		if (!bits)
 			goto out_nofds;
 	}
diff --git a/fs/seq_file.c b/fs/seq_file.c
index b17ee4c4f618..c82ca4c6376b 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -35,7 +35,7 @@ static void *seq_buf_alloc(unsigned long size)
 	if (unlikely(size > MAX_RW_COUNT))
 		return NULL;
 
-	return kvmalloc(size, GFP_KERNEL_ACCOUNT);
+	return kvmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_IUBIK);
 }
 
 /**
diff --git a/fs/signalfd.c b/fs/signalfd.c
index 65ce0e72e7b9..6dd7c6207a5d 100644
--- a/fs/signalfd.c
+++ b/fs/signalfd.c
@@ -264,7 +264,7 @@ static int do_signalfd4(int ufd, sigset_t *mask, int flags)
 	signotset(mask);
 
 	if (ufd == -1) {
-		ctx = kmalloc(sizeof(*ctx), GFP_KERNEL);
+		ctx = kmalloc(sizeof(*ctx), GFP_KERNEL | __GFP_IUBIK);
 		if (!ctx)
 			return -ENOMEM;
 
diff --git a/fs/xattr.c b/fs/xattr.c
index c17327f2239c..a94fc36d4a4e 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -693,7 +693,7 @@ getxattr(struct user_namespace *mnt_userns, struct dentry *d,
 	if (size) {
 		if (size > XATTR_SIZE_MAX)
 			size = XATTR_SIZE_MAX;
-		kvalue = kvzalloc(size, GFP_KERNEL);
+		kvalue = kvzalloc(size, GFP_KERNEL | __GFP_IUBIK);
 		if (!kvalue)
 			return -ENOMEM;
 	}
@@ -977,16 +977,16 @@ EXPORT_SYMBOL(xattr_full_name);
 struct simple_xattr *simple_xattr_alloc(const void *value, size_t size)
 {
 	struct simple_xattr *new_xattr;
-	size_t len;
 
-	/* wrap around? */
-	len = sizeof(*new_xattr) + size;
-	if (len < sizeof(*new_xattr))
+	new_xattr = kvmalloc(sizeof(*new_xattr), GFP_KERNEL);
+	if (!new_xattr)
 		return NULL;
 
-	new_xattr = kvmalloc(len, GFP_KERNEL);
-	if (!new_xattr)
+	new_xattr->value = kvmalloc(size, GFP_KERNEL_IUBIK);
+	if (!new_xattr->value) {
+		kvfree(new_xattr);
 		return NULL;
+	}
 
 	new_xattr->size = size;
 	memcpy(new_xattr->value, value, size);
@@ -1054,6 +1054,7 @@ int simple_xattr_set(struct simple_xattrs *xattrs, const char *name,
 
 		new_xattr->name = kstrdup(name, GFP_KERNEL);
 		if (!new_xattr->name) {
+			kvfree(new_xattr->value);
 			kvfree(new_xattr);
 			return -ENOMEM;
 		}
@@ -1088,6 +1089,7 @@ int simple_xattr_set(struct simple_xattrs *xattrs, const char *name,
 	spin_unlock(&xattrs->lock);
 	if (xattr) {
 		kfree(xattr->name);
+		kvfree(xattr->value);
 		kvfree(xattr);
 	}
 	return err;
diff --git a/include/asm-generic/asm-prototypes.h b/include/asm-generic/asm-prototypes.h
index 2fa2bc208383..fed2131ecc95 100644
--- a/include/asm-generic/asm-prototypes.h
+++ b/include/asm-generic/asm-prototypes.h
@@ -12,3 +12,5 @@ extern void *memset(void *, int, __kernel_size_t);
 extern void *memcpy(void *, const void *, __kernel_size_t);
 #undef memmove
 extern void *memmove(void *, const void *, __kernel_size_t);
+extern void *asm_iubik_pac_sign(void *, void *);
+extern void *asm_iubik_pac_auth(void *, void *);
diff --git a/include/keys/user-type.h b/include/keys/user-type.h
index 386c31432789..960268c5e73e 100644
--- a/include/keys/user-type.h
+++ b/include/keys/user-type.h
@@ -27,7 +27,7 @@
 struct user_key_payload {
 	struct rcu_head	rcu;		/* RCU destructor */
 	unsigned short	datalen;	/* length of this data */
-	char		data[] __aligned(__alignof__(u64)); /* actual data */
+	char		*data; /* actual data */
 };
 
 extern struct key_type key_type_user;
diff --git a/include/linux/binfmts.h b/include/linux/binfmts.h
index f821b7243361..abe2e1042d4c 100644
--- a/include/linux/binfmts.h
+++ b/include/linux/binfmts.h
@@ -62,8 +62,8 @@ struct linux_binprm {
 	unsigned long loader, exec;
 
 	struct rlimit rlim_stack; /* Saved RLIMIT_STACK used during exec. */
-
-	char buf[BINPRM_BUF_SIZE];
+#define sizeof__linux_binprm__buf BINPRM_BUF_SIZE
+	char *buf;
 } __randomize_layout;
 
 #define BINPRM_FLAGS_ENFORCE_NONDUMP_BIT 0
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2fe805c08e86..fc3d85511208 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1032,7 +1032,7 @@ struct file_handle {
 	__u32 handle_bytes;
 	int handle_type;
 	/* file identifier */
-	unsigned char f_handle[];
+	unsigned char *f_handle;
 };
 
 static inline struct file *get_file(struct file *f)
@@ -2718,9 +2718,9 @@ struct filename {
 	const __user char	*uptr;	/* original userland pointer */
 	int			refcnt;
 	struct audit_names	*aname;
-	const char		iname[];
+#define sizeof__filename__iname PATH_MAX
+	const char		*iname;
 };
-static_assert(offsetof(struct filename, iname) % sizeof(long) == 0);
 
 static inline struct user_namespace *file_mnt_user_ns(struct file *file)
 {
@@ -2783,9 +2783,13 @@ extern void __init vfs_caches_init_early(void);
 extern void __init vfs_caches_init(void);
 
 extern struct kmem_cache *names_cachep;
+extern struct kmem_cache *inames_cachep;
 
-#define __getname()		kmem_cache_alloc(names_cachep, GFP_KERNEL)
-#define __putname(name)		kmem_cache_free(names_cachep, (void *)(name))
+#define __getname()		kmem_cache_alloc(inames_cachep, GFP_KERNEL)	
+#define __putname(name)		kmem_cache_free(inames_cachep, (void *)(name))
+
+#define __getfilename()		kmem_cache_alloc(names_cachep, GFP_KERNEL)	
+#define __putfilename(name)	kmem_cache_free(names_cachep, (void *)(name))
 
 extern struct super_block *blockdev_superblock;
 static inline bool sb_is_blkdev_sb(struct super_block *sb)
diff --git a/include/linux/gfp.h b/include/linux/gfp.h
index b86ae05b4282..d27def352b1b 100644
--- a/include/linux/gfp.h
+++ b/include/linux/gfp.h
@@ -78,6 +78,10 @@ struct vm_area_struct;
 #define ___GFP_NOLOCKDEP	0
 #endif
 
+#ifdef CONFIG_IUBIK
+#define ___GFP_IUBIK		0x10000000u
+#endif
+
 /* If the above are modified, __GFP_BITS_SHIFT may need updating */
 
 /*
@@ -274,9 +278,11 @@ struct vm_area_struct;
 /* Disable lockdep for GFP context tracking */
 #define __GFP_NOLOCKDEP ((__force gfp_t)___GFP_NOLOCKDEP)
 
+#define __GFP_IUBIK ((__force gfp_t)___GFP_IUBIK)
+
 /* Room for N __GFP_FOO bits */
 #ifdef CONFIG_CMA
-#define __GFP_BITS_SHIFT (28 + IS_ENABLED(CONFIG_LOCKDEP))
+#define __GFP_BITS_SHIFT (28 + IS_ENABLED(CONFIG_LOCKDEP) + IS_ENABLED(CONFIG_IUBIK))
 #else
 #define __GFP_BITS_SHIFT (27 + IS_ENABLED(CONFIG_LOCKDEP))
 #endif
@@ -352,6 +358,7 @@ struct vm_area_struct;
  */
 #define GFP_ATOMIC	(__GFP_HIGH|__GFP_ATOMIC|__GFP_KSWAPD_RECLAIM)
 #define GFP_KERNEL	(__GFP_RECLAIM | __GFP_IO | __GFP_FS)
+#define GFP_KERNEL_IUBIK	(__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_IUBIK)
 #define GFP_KERNEL_ACCOUNT (GFP_KERNEL | __GFP_ACCOUNT)
 #define GFP_NOWAIT	(__GFP_KSWAPD_RECLAIM)
 #define GFP_NOIO	(__GFP_RECLAIM)
diff --git a/include/linux/inetdevice.h b/include/linux/inetdevice.h
index a038feb63f23..831ac92ac30b 100644
--- a/include/linux/inetdevice.h
+++ b/include/linux/inetdevice.h
@@ -147,7 +147,8 @@ struct in_ifaddr {
 	unsigned char		ifa_scope;
 	unsigned char		ifa_prefixlen;
 	__u32			ifa_flags;
-	char			ifa_label[IFNAMSIZ];
+#define sizeof__in_ifaddr__ifa_label IFNAMSIZ
+	char			*ifa_label;
 
 	/* In seconds, relative to tstamp. Expiry is at tstamp + HZ * lft. */
 	__u32			ifa_valid_lft;
diff --git a/include/linux/input.h b/include/linux/input.h
index dbf4ba68e477..ec8c77247721 100644
--- a/include/linux/input.h
+++ b/include/linux/input.h
@@ -143,15 +143,24 @@ struct input_dev {
 
 	unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];
 
-	unsigned long evbit[BITS_TO_LONGS(EV_CNT)];
-	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
-	unsigned long relbit[BITS_TO_LONGS(REL_CNT)];
-	unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];
-	unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];
-	unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];
-	unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];
-	unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];
-	unsigned long swbit[BITS_TO_LONGS(SW_CNT)];
+#define sizeof__input_dev__evbit (BITS_TO_LONGS(EV_CNT)	* sizeof(unsigned long))
+	unsigned long *evbit;
+#define sizeof__input_dev__keybit (BITS_TO_LONGS(KEY_CNT) * sizeof(unsigned long))
+	unsigned long *keybit;
+#define sizeof__input_dev__relbit (BITS_TO_LONGS(REL_CNT) * sizeof(unsigned long))
+	unsigned long *relbit;
+#define sizeof__input_dev__absbit (BITS_TO_LONGS(ABS_CNT) * sizeof(unsigned long))
+	unsigned long *absbit;
+#define sizeof__input_dev__mscbit (BITS_TO_LONGS(MSC_CNT) * sizeof(unsigned long))
+	unsigned long *mscbit;
+#define sizeof__input_dev__ledbit (BITS_TO_LONGS(LED_CNT) * sizeof(unsigned long))
+	unsigned long *ledbit;
+#define sizeof__input_dev__sndbit (BITS_TO_LONGS(SND_CNT) * sizeof(unsigned long))
+	unsigned long *sndbit;
+#define sizeof__input_dev__ffbit (BITS_TO_LONGS(FF_CNT)	* sizeof(unsigned long))
+	unsigned long *ffbit;
+#define sizeof__input_dev__swbit (BITS_TO_LONGS(SW_CNT)	* sizeof(unsigned long))
+	unsigned long *swbit;
 
 	unsigned int hint_events_per_packet;
 
diff --git a/include/linux/kasan-enabled.h b/include/linux/kasan-enabled.h
index 6f612d69ea0c..db89613f3ce8 100644
--- a/include/linux/kasan-enabled.h
+++ b/include/linux/kasan-enabled.h
@@ -7,6 +7,12 @@
 #ifdef CONFIG_KASAN_HW_TAGS
 
 DECLARE_STATIC_KEY_FALSE(kasan_flag_enabled);
+DECLARE_STATIC_KEY_FALSE(iubik_kasan_flag_enabled);
+
+static __always_inline bool iubik_kasan_enabled(void)
+{
+	return static_branch_likely(&iubik_kasan_flag_enabled);
+}
 
 static __always_inline bool kasan_enabled(void)
 {
diff --git a/include/linux/key.h b/include/linux/key.h
index 7febc4881363..01e2ca2ca13f 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -105,21 +105,12 @@ struct key_tag {
 	bool			removed;	/* T when subject removed */
 };
 
+#define index_key_x(index_key) (index_key->desc_len | ((*(unsigned long *)index_key->description) << 2))
+
 struct keyring_index_key {
 	/* [!] If this structure is altered, the union in struct key must change too! */
 	unsigned long		hash;			/* Hash value */
-	union {
-		struct {
-#ifdef __LITTLE_ENDIAN /* Put desc_len at the LSB of x */
-			u16	desc_len;
-			char	desc[sizeof(long) - 2];	/* First few chars of description */
-#else
-			char	desc[sizeof(long) - 2];	/* First few chars of description */
-			u16	desc_len;
-#endif
-		};
-		unsigned long x;
-	};
+	unsigned long		desc_len;
 	struct key_type		*type;
 	struct key_tag		*domain_tag;	/* Domain of operation */
 	const char		*description;
diff --git a/include/linux/kobject.h b/include/linux/kobject.h
index fdfab3b9d33c..0d5c7446d61e 100644
--- a/include/linux/kobject.h
+++ b/include/linux/kobject.h
@@ -160,7 +160,8 @@ struct kobj_uevent_env {
 	char *argv[3];
 	char *envp[UEVENT_NUM_ENVP];
 	int envp_idx;
-	char buf[UEVENT_BUFFER_SIZE];
+#define sizeof__kobj_uevent_env__buf UEVENT_BUFFER_SIZE
+	char *buf;
 	int buflen;
 };
 
diff --git a/include/linux/mm.h b/include/linux/mm.h
index a9d717452229..1a366f8e2c8d 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1558,7 +1558,7 @@ static inline u8 page_kasan_tag(const struct page *page)
 {
 	u8 tag = 0xff;
 
-	if (kasan_enabled()) {
+	if (iubik_kasan_enabled()) {
 		tag = (page->flags >> KASAN_TAG_PGSHIFT) & KASAN_TAG_MASK;
 		tag ^= 0xff;
 	}
@@ -1582,10 +1582,26 @@ static inline void page_kasan_tag_set(struct page *page, u8 tag)
 	} while (unlikely(!try_cmpxchg(&page->flags, &old_flags, flags)));
 }
 
+static inline void page_iubik_tag_set(struct page *page, u8 tag)
+{
+	unsigned long old_flags, flags;
+
+	if (!iubik_kasan_enabled())
+		return;
+
+	tag ^= 0xff;
+	old_flags = READ_ONCE(page->flags);
+	do {
+		flags = old_flags;
+		flags &= ~(KASAN_TAG_MASK << KASAN_TAG_PGSHIFT);
+		flags |= (tag & KASAN_TAG_MASK) << KASAN_TAG_PGSHIFT;
+	} while (unlikely(!try_cmpxchg(&page->flags, &old_flags, flags)));
+}
+
 static inline void page_kasan_tag_reset(struct page *page)
 {
-	if (kasan_enabled())
-		page_kasan_tag_set(page, 0xff);
+	if (iubik_kasan_enabled())
+		page_iubik_tag_set(page, 0xff);
 }
 
 #else /* CONFIG_KASAN_SW_TAGS || CONFIG_KASAN_HW_TAGS */
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 076bb5eb99f2..8b9091e0b408 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -557,7 +557,8 @@ struct mm_struct {
 		unsigned long start_brk, brk, start_stack;
 		unsigned long arg_start, arg_end, env_start, env_end;
 
-		unsigned long saved_auxv[AT_VECTOR_SIZE]; /* for /proc/PID/auxv */
+#define sizeof__mm_struct__saved_auxv (AT_VECTOR_SIZE * sizeof(unsigned long))
+		unsigned long *saved_auxv; /* for /proc/PID/auxv */
 
 		/*
 		 * Special counters, in some configurations protected by the
diff --git a/include/linux/msg.h b/include/linux/msg.h
index 9a972a296b95..d40bf26d7407 100644
--- a/include/linux/msg.h
+++ b/include/linux/msg.h
@@ -12,6 +12,7 @@ struct msg_msg {
 	size_t m_ts;		/* message text size */
 	struct msg_msgseg *next;
 	void *security;
+	char *user_data;
 	/* the actual message follows immediately */
 };
 
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 80c9b30796f7..c2078482873f 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -218,7 +218,8 @@ struct sk_buff;
 struct netdev_hw_addr {
 	struct list_head	list;
 	struct rb_node		node;
-	unsigned char		addr[MAX_ADDR_LEN];
+#define sizeof__ha__addr	MAX_ADDR_LEN
+	unsigned char		*addr;
 	unsigned char		type;
 #define NETDEV_HW_ADDR_T_LAN		1
 #define NETDEV_HW_ADDR_T_SAN		2
@@ -2005,7 +2006,8 @@ enum netdev_ml_priv_type {
  */
 
 struct net_device {
-	char			name[IFNAMSIZ];
+#define sizeof__net_device__name IFNAMSIZ 
+	char			*name;
 	struct netdev_name_node	*name_node;
 	struct dev_ifalias	__rcu *ifalias;
 	/*
@@ -5334,7 +5336,7 @@ extern struct pernet_operations __net_initdata loopback_net_ops;
 
 static inline const char *netdev_name(const struct net_device *dev)
 {
-	if (!dev->name[0] || strchr(dev->name, '%'))
+	if (!dev->name || strchr(dev->name, '%'))
 		return "(unnamed net_device)";
 	return dev->name;
 }
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 10dfe9dc06a6..44bdf6e7b3dc 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -1514,7 +1514,7 @@ static inline void skb_set_end_offset(struct sk_buff *skb, unsigned int offset)
 #endif
 
 /* Internal */
-#define skb_shinfo(SKB)	((struct skb_shared_info *)(skb_end_pointer(SKB)))
+#define skb_shinfo(SKB)	((struct skb_shared_info *)(iubik_tag_set_domk(skb_end_pointer(SKB))))
 
 static inline struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)
 {
diff --git a/include/linux/slab.h b/include/linux/slab.h
index e82594244dcd..ce5fe3e0bbc5 100644
--- a/include/linux/slab.h
+++ b/include/linux/slab.h
@@ -120,6 +120,13 @@
 /* Slab deactivation flag */
 #define SLAB_DEACTIVATED	((slab_flags_t __force)0x10000000U)
 
+/* IUBIK Slab */
+#ifdef CONFIG_IUBIK
+#define SLAB_IUBIK		((slab_flags_t __force)0x20000000U)
+#else
+#define SLAB_IUBIK		0
+#endif
+
 /*
  * ZERO_SIZE_PTR will be returned for zero sized kmalloc requests.
  *
@@ -315,10 +322,16 @@ enum kmalloc_cache_type {
 #ifndef CONFIG_ZONE_DMA
 	KMALLOC_DMA = KMALLOC_NORMAL,
 #endif
+#ifndef CONFIG_IUBIK
+	KMALLOC_IUBIK = KMALLOC_NORMAL,
+#endif
 #ifndef CONFIG_MEMCG_KMEM
 	KMALLOC_CGROUP = KMALLOC_NORMAL,
 #else
 	KMALLOC_CGROUP,
+#endif
+#ifdef CONFIG_IUBIK
+	KMALLOC_IUBIK,
 #endif
 	KMALLOC_RECLAIM,
 #ifdef CONFIG_ZONE_DMA
@@ -337,7 +350,8 @@ kmalloc_caches[NR_KMALLOC_TYPES][KMALLOC_SHIFT_HIGH + 1];
 #define KMALLOC_NOT_NORMAL_BITS					\
 	(__GFP_RECLAIMABLE |					\
 	(IS_ENABLED(CONFIG_ZONE_DMA)   ? __GFP_DMA : 0) |	\
-	(IS_ENABLED(CONFIG_MEMCG_KMEM) ? __GFP_ACCOUNT : 0))
+	(IS_ENABLED(CONFIG_MEMCG_KMEM) ? __GFP_ACCOUNT : 0) |	\
+	(IS_ENABLED(CONFIG_IUBIK) ? __GFP_IUBIK : 0))
 
 static __always_inline enum kmalloc_cache_type kmalloc_type(gfp_t flags)
 {
@@ -355,6 +369,8 @@ static __always_inline enum kmalloc_cache_type kmalloc_type(gfp_t flags)
 	 *  2) __GFP_RECLAIMABLE
 	 *  3) __GFP_ACCOUNT
 	 */
+	if (IS_ENABLED(CONFIG_IUBIK) && (flags & __GFP_IUBIK))
+		return KMALLOC_IUBIK;
 	if (IS_ENABLED(CONFIG_ZONE_DMA) && (flags & __GFP_DMA))
 		return KMALLOC_DMA;
 	if (!IS_ENABLED(CONFIG_MEMCG_KMEM) || (flags & __GFP_RECLAIMABLE))
@@ -743,4 +759,34 @@ int slab_dead_cpu(unsigned int cpu);
 #define slab_dead_cpu		NULL
 #endif
 
+#ifdef CONFIG_IUBIK
+#define IUBIK_TAG_DOMU 0xf1
+#define IUBIK_TAG_DOMK 0xf2
+
+static inline void iubik_set_mem_tag_range_domu(void *addr, size_t size)
+{
+	mte_set_mem_tag_range(addr, size, IUBIK_TAG_DOMU, false);
+}
+
+static inline void iubik_set_mem_tag_range_domk(void *addr, size_t size)
+{
+	mte_set_mem_tag_range(addr, size, IUBIK_TAG_DOMK, false);
+}
+
+static inline void *iubik_tag_set_domu(void *p)
+{
+	return (void *)__tag_set(p, IUBIK_TAG_DOMU);
+}
+
+static inline void *iubik_tag_set_domk(void *p)
+{
+	return (void *)__tag_set(p, IUBIK_TAG_DOMK);
+}
+#else
+static inline void iubik_set_mem_tag_range_domu(void *addr, size_t size) {}
+static inline void iubik_set_mem_tag_range_domk(void *addr, size_t size) {}
+static inline void *iubik_tag_set_domu(void *p) {}
+static inline void *iubik_tag_set_domk(void *p) {}
+#endif
+
 #endif	/* _LINUX_SLAB_H */
diff --git a/include/linux/tty_buffer.h b/include/linux/tty_buffer.h
index 3b9d77604291..da8cc10cd1f8 100644
--- a/include/linux/tty_buffer.h
+++ b/include/linux/tty_buffer.h
@@ -18,7 +18,7 @@ struct tty_buffer {
 	int read;
 	int flags;
 	/* Data points here */
-	unsigned long data[];
+	unsigned long *data;
 };
 
 /* Values for .flags field of tty_buffer */
diff --git a/include/linux/xattr.h b/include/linux/xattr.h
index 4c379d23ec6e..aa6fd3a43ef9 100644
--- a/include/linux/xattr.h
+++ b/include/linux/xattr.h
@@ -88,7 +88,7 @@ struct simple_xattr {
 	struct list_head list;
 	char *name;
 	size_t size;
-	char value[];
+	char *value;
 };
 
 /*
@@ -109,6 +109,7 @@ static inline void simple_xattrs_free(struct simple_xattrs *xattrs)
 
 	list_for_each_entry_safe(xattr, node, &xattrs->head, list) {
 		kfree(xattr->name);
+		kvfree(xattr->value);
 		kvfree(xattr);
 	}
 }
diff --git a/include/net/af_unix.h b/include/net/af_unix.h
index 01f3aec7128c..cf2e7d613729 100644
--- a/include/net/af_unix.h
+++ b/include/net/af_unix.h
@@ -27,7 +27,7 @@ struct unix_address {
 	refcount_t	refcnt;
 	int		len;
 	unsigned int	hash;
-	struct sockaddr_un name[];
+	struct sockaddr_un *name;
 };
 
 struct unix_skb_parms {
diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 8ec0878a90a7..f580578d66fd 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -35,7 +35,7 @@ enum {
 };
 
 struct inet6_ifaddr {
-	struct in6_addr		addr;
+	struct in6_addr		*addr;
 	__u32			prefix_len;
 	__u32			rt_priority;
 
@@ -206,7 +206,7 @@ struct inet6_dev {
 	u32			desync_factor;
 	struct list_head	tempaddr_list;
 
-	struct in6_addr		token;
+	struct in6_addr		*token;
 
 	struct neigh_parms	*nd_parms;
 	struct ipv6_devconf	cnf;
diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h
index 60b27029b70d..dd6a2c77a43b 100644
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@ -210,7 +210,7 @@ struct fib6_info {
 
 	ANDROID_KABI_RESERVE(1);
 
-	struct fib6_nh			fib6_nh[];
+	struct fib6_nh			*fib6_nh;
 };
 
 struct rt6_info {
diff --git a/include/net/neighbour.h b/include/net/neighbour.h
index 0745c7baf617..5e0d12a7e2b7 100644
--- a/include/net/neighbour.h
+++ b/include/net/neighbour.h
@@ -163,7 +163,7 @@ struct neighbour {
 
 	ANDROID_KABI_RESERVE(1);
 
-	u8			primary_key[0];
+	u8			*primary_key;
 } __randomize_layout;
 
 struct neigh_ops {
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index a0b47f2b896e..1a8029c88e3c 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -242,7 +242,7 @@ int nft_parse_register_store(const struct nft_ctx *ctx,
  */
 struct nft_userdata {
 	u8			len;
-	unsigned char		data[];
+	unsigned char		*data;
 };
 
 /**
@@ -681,7 +681,7 @@ static inline int nft_set_ext_add_length(struct nft_set_ext_tmpl *tmpl, u8 id,
 		return -EINVAL;
 
 	tmpl->offset[id] = tmpl->len;
-	tmpl->len	+= nft_set_ext_types[id].len + len;
+	tmpl->len	+= nft_set_ext_types[id].len;
 
 	return 0;
 }
diff --git a/include/uapi/linux/tipc.h b/include/uapi/linux/tipc.h
index 80ea15e12113..eb0853bdcf26 100644
--- a/include/uapi/linux/tipc.h
+++ b/include/uapi/linux/tipc.h
@@ -239,9 +239,10 @@ struct tipc_sioc_nodeid_req {
 #define TIPC_AEAD_ALG_NAME		(32)
 
 struct tipc_aead_key {
-	char alg_name[TIPC_AEAD_ALG_NAME];
+#define sizeof__tipc_key__alg_name TIPC_AEAD_ALG_NAME
+	char *alg_name;
 	unsigned int keylen;	/* in bytes */
-	char key[];
+	char *key;
 };
 
 #define TIPC_AEAD_KEYLEN_MIN		(16 + 4)
diff --git a/init/Kconfig b/init/Kconfig
index 57a8e6746a42..37193494b357 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1980,6 +1980,34 @@ config SLAB_FREELIST_HARDENED
 	  sanity-checking than others. This option is most effective with
 	  CONFIG_SLUB.
 
+config IUBIK
+        bool "Isolate caches touched by user-space"
+        default y
+       	depends on SLUB 
+        help
+         Maintain a separate set of isolated kmalloc caches that allocate
+         objects which might be touched by user-space data.
+
+config IUBIK_INTROSPECTION
+	bool "Enable introspection on data transferred to/from user-space"
+        default y
+       	depends on SLUB 
+        help
+	 Prevent pointers from being transferred to/from user-space during
+	 copy_to/from_user on objects that were not allocated via IUBIK.
+
+config IUBIK_MEMBENCH
+    bool "Enable memory benchmark counters that keep track of the max RSS."
+    default n
+    help
+        lorem ipsum.
+
+config IUBIK_BACKREF_PAC
+    bool "PAC based protection of backwards reference pointers. Disable to use MTE based protection."
+    default y
+    help
+        lorem ipsum.
+
 config SHUFFLE_PAGE_ALLOCATOR
 	bool "Page allocator randomization"
 	default SLAB_FREELIST_RANDOM && ACPI_NUMA
diff --git a/ipc/msgutil.c b/ipc/msgutil.c
index d0a0e877cadd..e45117b5fb0a 100644
--- a/ipc/msgutil.c
+++ b/ipc/msgutil.c
@@ -36,11 +36,12 @@ struct ipc_namespace init_ipc_ns = {
 
 struct msg_msgseg {
 	struct msg_msgseg *next;
+	char *user_data;
 	/* the next part of the message follows immediately */
 };
 
-#define DATALEN_MSG	((size_t)PAGE_SIZE-sizeof(struct msg_msg))
-#define DATALEN_SEG	((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))
+#define DATALEN_MSG	((size_t)PAGE_SIZE)
+#define DATALEN_SEG	((size_t)PAGE_SIZE)
 
 
 static struct msg_msg *alloc_msg(size_t len)
@@ -50,10 +51,16 @@ static struct msg_msg *alloc_msg(size_t len)
 	size_t alen;
 
 	alen = min(len, DATALEN_MSG);
-	msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);
+	msg = kmalloc(sizeof(*msg), GFP_KERNEL_ACCOUNT);
 	if (msg == NULL)
 		return NULL;
 
+	msg->user_data = kmalloc(alen, GFP_KERNEL_ACCOUNT | __GFP_IUBIK);
+	if (msg->user_data == NULL){
+		kfree(msg);
+		return NULL;
+	}
+
 	msg->next = NULL;
 	msg->security = NULL;
 
@@ -65,9 +72,12 @@ static struct msg_msg *alloc_msg(size_t len)
 		cond_resched();
 
 		alen = min(len, DATALEN_SEG);
-		seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);
+		seg = kmalloc(sizeof(*seg), GFP_KERNEL_ACCOUNT);
 		if (seg == NULL)
 			goto out_err;
+		seg->user_data = kmalloc(alen, GFP_KERNEL_ACCOUNT | __GFP_IUBIK);
+		if(seg->user_data == NULL)
+			goto out_err;
 		*pseg = seg;
 		seg->next = NULL;
 		pseg = &seg->next;
@@ -93,14 +103,14 @@ struct msg_msg *load_msg(const void __user *src, size_t len)
 		return ERR_PTR(-ENOMEM);
 
 	alen = min(len, DATALEN_MSG);
-	if (copy_from_user(msg + 1, src, alen))
+	if (copy_from_user(msg->user_data, src, alen))
 		goto out_err;
 
 	for (seg = msg->next; seg != NULL; seg = seg->next) {
 		len -= alen;
 		src = (char __user *)src + alen;
 		alen = min(len, DATALEN_SEG);
-		if (copy_from_user(seg + 1, src, alen))
+		if (copy_from_user(seg->user_data, src, alen))
 			goto out_err;
 	}
 
@@ -125,7 +135,7 @@ struct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)
 		return ERR_PTR(-EINVAL);
 
 	alen = min(len, DATALEN_MSG);
-	memcpy(dst + 1, src + 1, alen);
+	memcpy(dst->user_data, src->user_data, alen);
 
 	for (dst_pseg = dst->next, src_pseg = src->next;
 	     src_pseg != NULL;
@@ -133,7 +143,7 @@ struct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)
 
 		len -= alen;
 		alen = min(len, DATALEN_SEG);
-		memcpy(dst_pseg + 1, src_pseg + 1, alen);
+		memcpy(dst_pseg->user_data, src_pseg->user_data, alen);
 	}
 
 	dst->m_type = src->m_type;
@@ -153,14 +163,14 @@ int store_msg(void __user *dest, struct msg_msg *msg, size_t len)
 	struct msg_msgseg *seg;
 
 	alen = min(len, DATALEN_MSG);
-	if (copy_to_user(dest, msg + 1, alen))
+	if (copy_to_user(dest, msg->user_data, alen))
 		return -1;
 
 	for (seg = msg->next; seg != NULL; seg = seg->next) {
 		len -= alen;
 		dest = (char __user *)dest + alen;
 		alen = min(len, DATALEN_SEG);
-		if (copy_to_user(dest, seg + 1, alen))
+		if (copy_to_user(dest, seg->user_data, alen))
 			return -1;
 	}
 	return 0;
@@ -173,11 +183,13 @@ void free_msg(struct msg_msg *msg)
 	security_msg_msg_free(msg);
 
 	seg = msg->next;
+	kfree(msg->user_data);
 	kfree(msg);
 	while (seg != NULL) {
 		struct msg_msgseg *tmp = seg->next;
 
 		cond_resched();
+		kfree(seg->user_data);
 		kfree(seg);
 		seg = tmp;
 	}
diff --git a/kernel/cgroup/cgroup.c b/kernel/cgroup/cgroup.c
index 3de209d57c19..7ff3cd7d1b0a 100644
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@ -6087,7 +6087,7 @@ int proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,
 	struct cgroup_root *root;
 
 	retval = -ENOMEM;
-	buf = kmalloc(PATH_MAX, GFP_KERNEL);
+	buf = kmalloc(PATH_MAX, GFP_KERNEL | __GFP_IUBIK);
 	if (!buf)
 		goto out;
 
diff --git a/kernel/fork.c b/kernel/fork.c
index e26c9f558bdc..17d74ab806d5 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -751,6 +751,7 @@ void __mmdrop(struct mm_struct *mm)
 	mmu_notifier_subscriptions_destroy(mm);
 	check_mm(mm);
 	put_user_ns(mm->user_ns);
+	kfree(mm->saved_auxv);
 	free_mm(mm);
 }
 EXPORT_SYMBOL_GPL(__mmdrop);
@@ -1119,6 +1120,13 @@ static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
 	mm_init_owner(mm, p);
 	mm_init_pasid(mm);
 	RCU_INIT_POINTER(mm->exe_file, NULL);
+	
+	mm->saved_auxv = kzalloc(sizeof__mm_struct__saved_auxv, GFP_KERNEL_IUBIK); 
+	if (!mm->saved_auxv) {
+		free_mm(mm);
+		goto fail_noauxv;	
+	}
+	
 	if (!mmu_notifier_subscriptions_init(mm))
 		goto fail_nopgd;
 	init_tlb_flush_pending(mm);
@@ -1149,6 +1157,8 @@ static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
 fail_nocontext:
 	mm_free_pgd(mm);
 fail_nopgd:
+	kfree(mm->saved_auxv);
+fail_noauxv:
 	free_mm(mm);
 	return NULL;
 }
@@ -1165,6 +1175,7 @@ struct mm_struct *mm_alloc(void)
 		return NULL;
 
 	memset(mm, 0, sizeof(*mm));
+
 	return mm_init(mm, current, current_user_ns());
 }
 
@@ -1515,6 +1526,8 @@ static struct mm_struct *dup_mm(struct task_struct *tsk,
 
 	if (!mm_init(mm, tsk, mm->user_ns))
 		goto fail_nomem;
+	
+	memcpy(mm->saved_auxv, oldmm->saved_auxv, sizeof__mm_struct__saved_auxv);
 
 	err = dup_mmap(mm, oldmm);
 	if (err)
@@ -3000,11 +3013,9 @@ void __init mm_cache_init(void)
 	 */
 	mm_size = sizeof(struct mm_struct) + cpumask_size();
 
-	mm_cachep = kmem_cache_create_usercopy("mm_struct",
+	mm_cachep = kmem_cache_create("mm_struct",
 			mm_size, ARCH_MIN_MMSTRUCT_ALIGN,
 			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,
-			offsetof(struct mm_struct, saved_auxv),
-			sizeof_field(struct mm_struct, saved_auxv),
 			NULL);
 }
 
diff --git a/kernel/irq/msi.c b/kernel/irq/msi.c
index d75586dc584f..20df6a88b801 100644
--- a/kernel/irq/msi.c
+++ b/kernel/irq/msi.c
@@ -133,7 +133,7 @@ const struct attribute_group **msi_populate_sysfs(struct device *dev)
 			msi_attrs[count] = &msi_dev_attr->attr;
 
 			sysfs_attr_init(&msi_dev_attr->attr);
-			msi_dev_attr->attr.name = kasprintf(GFP_KERNEL, "%d",
+			msi_dev_attr->attr.name = kasprintf(GFP_KERNEL | __GFP_IUBIK, "%d",
 							    entry->irq + i);
 			if (!msi_dev_attr->attr.name)
 				goto error_attrs;
diff --git a/kernel/module.c b/kernel/module.c
index f9b826a56882..0e5d19b0f204 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -1583,7 +1583,7 @@ static void add_sect_attrs(struct module *mod, const struct load_info *info)
 		sysfs_bin_attr_init(&sattr->battr);
 		sattr->address = sec->sh_addr;
 		sattr->battr.attr.name =
-			kstrdup(info->secstrings + sec->sh_name, GFP_KERNEL);
+			kstrdup(info->secstrings + sec->sh_name, GFP_KERNEL | __GFP_IUBIK);
 		if (sattr->battr.attr.name == NULL)
 			goto out;
 		sect_attrs->nsections++;
diff --git a/kernel/power/hibernate.c b/kernel/power/hibernate.c
index 9abc73d500fb..53ac98f218fb 100644
--- a/kernel/power/hibernate.c
+++ b/kernel/power/hibernate.c
@@ -1161,7 +1161,7 @@ static ssize_t resume_store(struct kobject *kobj, struct kobj_attribute *attr,
 
 	if (len && buf[len-1] == '\n')
 		len--;
-	name = kstrndup(buf, len, GFP_KERNEL);
+	name = kstrndup(buf, len, GFP_KERNEL | __GFP_IUBIK);
 	if (!name)
 		return -ENOMEM;
 
diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 41b7b07afcf5..c6069bc8888a 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -639,7 +639,8 @@ struct devkmsg_user {
 	atomic64_t seq;
 	struct ratelimit_state rs;
 	struct mutex lock;
-	char buf[CONSOLE_EXT_LOG_MAX];
+#define sizeof__devkmsg_user__buf CONSOLE_EXT_LOG_MAX
+	char *buf;
 
 	struct printk_info info;
 	char text_buf[CONSOLE_EXT_LOG_MAX];
@@ -682,7 +683,7 @@ static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 			return ret;
 	}
 
-	buf = kmalloc(len+1, GFP_KERNEL);
+	buf = kmalloc(len+1, GFP_KERNEL | __GFP_IUBIK);
 	if (buf == NULL)
 		return -ENOMEM;
 
@@ -766,8 +767,8 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf,
 		goto out;
 	}
 
-	len = info_print_ext_header(user->buf, sizeof(user->buf), r->info);
-	len += msg_print_ext_body(user->buf + len, sizeof(user->buf) - len,
+	len = info_print_ext_header(user->buf, sizeof__devkmsg_user__buf, r->info);
+	len += msg_print_ext_body(user->buf + len, sizeof__devkmsg_user__buf - len,
 				  &r->text_buf[0], r->info->text_len,
 				  &r->info->dev_info);
 
@@ -871,6 +872,12 @@ static int devkmsg_open(struct inode *inode, struct file *file)
 	if (!user)
 		return -ENOMEM;
 
+	user->buf = kmalloc(sizeof__devkmsg_user__buf, GFP_KERNEL_IUBIK);
+	if (!user->buf) {
+		kfree(user);
+		return -ENOMEM;
+	}
+	
 	ratelimit_default_init(&user->rs);
 	ratelimit_set_flags(&user->rs, RATELIMIT_MSG_ON_RELEASE);
 
@@ -895,6 +902,7 @@ static int devkmsg_release(struct inode *inode, struct file *file)
 	ratelimit_state_exit(&user->rs);
 
 	mutex_destroy(&user->lock);
+	kfree(user->buf);
 	kfree(user);
 	return 0;
 }
diff --git a/kernel/sys.c b/kernel/sys.c
index 2764b66b52dc..b0100f040404 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -1980,7 +1980,7 @@ static int prctl_set_mm_map(int opt, const void __user *addr, unsigned long data
 	struct mm_struct *mm = current->mm;
 	int error;
 
-	BUILD_BUG_ON(sizeof(user_auxv) != sizeof(mm->saved_auxv));
+	BUILD_BUG_ON(sizeof(user_auxv) != sizeof__mm_struct__saved_auxv);
 	BUILD_BUG_ON(sizeof(struct prctl_mm_map) > 256);
 
 	if (opt == PR_SET_MM_MAP_SIZE)
@@ -2002,7 +2002,7 @@ static int prctl_set_mm_map(int opt, const void __user *addr, unsigned long data
 		 * Someone is trying to cheat the auxv vector.
 		 */
 		if (!prctl_map.auxv ||
-				prctl_map.auxv_size > sizeof(mm->saved_auxv))
+				prctl_map.auxv_size > sizeof__mm_struct__saved_auxv)
 			return -EINVAL;
 
 		memset(user_auxv, 0, sizeof(user_auxv));
@@ -2102,7 +2102,7 @@ static int prctl_set_auxv(struct mm_struct *mm, unsigned long addr,
 	user_auxv[AT_VECTOR_SIZE - 2] = 0;
 	user_auxv[AT_VECTOR_SIZE - 1] = 0;
 
-	BUILD_BUG_ON(sizeof(user_auxv) != sizeof(mm->saved_auxv));
+	BUILD_BUG_ON(sizeof(user_auxv) != sizeof__mm_struct__saved_auxv);
 
 	task_lock(current);
 	memcpy(mm->saved_auxv, user_auxv, len);
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index d2dd14c5f712..b1193fc309b0 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -286,7 +286,8 @@ struct workqueue_struct {
 	struct lock_class_key	key;
 	struct lockdep_map	lockdep_map;
 #endif
-	char			name[WQ_NAME_LEN]; /* I: workqueue name */
+#define sizeof__workqueue__name WQ_NAME_LEN
+	char			*name; /* I: workqueue name */
 
 	/*
 	 * Destruction of workqueue_struct is RCU protected to allow walking
@@ -3547,6 +3548,7 @@ static void rcu_free_wq(struct rcu_head *rcu)
 	else
 		free_workqueue_attrs(wq->unbound_attrs);
 
+	kfree(wq->name);
 	kfree(wq);
 }
 
@@ -4333,6 +4335,12 @@ struct workqueue_struct *alloc_workqueue(const char *fmt,
 	wq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);
 	if (!wq)
 		return NULL;
+	
+	wq->name = kzalloc(sizeof__workqueue__name, GFP_KERNEL_IUBIK);
+	if (!wq->name) {
+		kfree(wq);
+		return NULL;
+	}
 
 	if (flags & WQ_UNBOUND) {
 		wq->unbound_attrs = alloc_workqueue_attrs();
@@ -4341,7 +4349,7 @@ struct workqueue_struct *alloc_workqueue(const char *fmt,
 	}
 
 	va_start(args, max_active);
-	vsnprintf(wq->name, sizeof(wq->name), fmt, args);
+	vsnprintf(wq->name, sizeof__workqueue__name, fmt, args);
 	va_end(args);
 
 	max_active = max_active ?: WQ_DFL_ACTIVE;
diff --git a/lib/bitmap.c b/lib/bitmap.c
index 663dd81967d4..f6ab2520455d 100644
--- a/lib/bitmap.c
+++ b/lib/bitmap.c
@@ -500,7 +500,7 @@ static int bitmap_print_to_buf(bool list, char *buf, const unsigned long *maskp,
 	ssize_t size;
 	void *data;
 
-	data = kasprintf(GFP_KERNEL, fmt, nmaskbits, maskp);
+	data = kasprintf(GFP_KERNEL | __GFP_IUBIK, fmt, nmaskbits, maskp);
 	if (!data)
 		return -ENOMEM;
 
diff --git a/lib/kobject.c b/lib/kobject.c
index b6ccb4cced63..0aa75ff1b596 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -294,7 +294,7 @@ int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
 	if (kobj->name && !fmt)
 		return 0;
 
-	s = kvasprintf_const(GFP_KERNEL, fmt, vargs);
+	s = kvasprintf_const(GFP_KERNEL | __GFP_IUBIK, fmt, vargs);
 	if (!s)
 		return -ENOMEM;
 
diff --git a/lib/kobject_uevent.c b/lib/kobject_uevent.c
index c87d5b6a8a55..7bf30ff1ddfb 100644
--- a/lib/kobject_uevent.c
+++ b/lib/kobject_uevent.c
@@ -128,6 +128,12 @@ static int kobject_action_args(const char *buf, size_t count,
 	env = kzalloc(sizeof(*env), GFP_KERNEL);
 	if (!env)
 		return -ENOMEM;
+	
+	env->buf = kzalloc(sizeof__kobj_uevent_env__buf, GFP_KERNEL_IUBIK);
+	if (!env->buf) {
+		kfree(env);
+		return -ENOMEM;
+	}
 
 	/* first arg is UUID */
 	if (count < UUID_STRING_LEN || !uuid_is_valid(buf) ||
@@ -172,8 +178,10 @@ static int kobject_action_args(const char *buf, size_t count,
 
 	r = 0;
 out:
-	if (r)
+	if (r) {
+		kfree(env->buf);
 		kfree(env);
+	}
 	else
 		*ret_env = env;
 	return r;
@@ -220,6 +228,7 @@ int kobject_synth_uevent(struct kobject *kobj, const char *buf, size_t count)
 		goto out;
 
 	r = kobject_uevent_env(kobj, action, env->envp);
+	kfree(env->buf);
 	kfree(env);
 out:
 	if (r) {
@@ -251,7 +260,7 @@ static int kobj_usermode_filter(struct kobject *kobj)
 
 static int init_uevent_argv(struct kobj_uevent_env *env, const char *subsystem)
 {
-	int buffer_size = sizeof(env->buf) - env->buflen;
+	int buffer_size = sizeof__kobj_uevent_env__buf - env->buflen;
 	int len;
 
 	len = strlcpy(&env->buf[env->buflen], subsystem, buffer_size);
@@ -525,6 +534,12 @@ int kobject_uevent_env(struct kobject *kobj, enum kobject_action action,
 	if (!env)
 		return -ENOMEM;
 
+	env->buf = kzalloc(sizeof__kobj_uevent_env__buf, GFP_KERNEL_IUBIK);
+	if (!env->buf) {
+		kfree(env);
+		return -ENOMEM;
+	}
+
 	/* complete object path */
 	devpath = kobject_get_path(kobj, GFP_KERNEL);
 	if (!devpath) {
@@ -623,6 +638,7 @@ int kobject_uevent_env(struct kobject *kobj, enum kobject_action action,
 
 exit:
 	kfree(devpath);
+	kfree(env->buf);
 	kfree(env);
 	return retval;
 }
@@ -663,11 +679,11 @@ int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)
 
 	va_start(args, format);
 	len = vsnprintf(&env->buf[env->buflen],
-			sizeof(env->buf) - env->buflen,
+			sizeof__kobj_uevent_env__buf - env->buflen,
 			format, args);
 	va_end(args);
 
-	if (len >= (sizeof(env->buf) - env->buflen)) {
+	if (len >= (sizeof__kobj_uevent_env__buf - env->buflen)) {
 		WARN(1, KERN_ERR "add_uevent_var: buffer size too small\n");
 		return -ENOMEM;
 	}
diff --git a/mm/kasan/hw_tags.c b/mm/kasan/hw_tags.c
index bc61de92cedd..2ba7d84dd777 100644
--- a/mm/kasan/hw_tags.c
+++ b/mm/kasan/hw_tags.c
@@ -49,6 +49,9 @@ static enum kasan_arg_vmalloc kasan_arg_vmalloc __initdata;
 DEFINE_STATIC_KEY_FALSE(kasan_flag_enabled);
 EXPORT_SYMBOL(kasan_flag_enabled);
 
+DEFINE_STATIC_KEY_FALSE(iubik_kasan_flag_enabled);
+EXPORT_SYMBOL(iubik_kasan_flag_enabled);
+
 /*
  * Whether the selected mode is synchronous, asynchronous, or asymmetric.
  * Defaults to KASAN_MODE_SYNC.
@@ -200,7 +203,7 @@ void kasan_init_hw_tags_cpu(void)
 	 */
 	if (kasan_arg == KASAN_ARG_OFF)
 		return;
-
+		
 	/*
 	 * Enable async or asymm modes only when explicitly requested
 	 * through the command line.
@@ -215,6 +218,10 @@ void __init kasan_init_hw_tags(void)
 	if (!system_supports_mte())
 		return;
 
+#if defined(CONFIG_IUBIK)
+        static_branch_enable(&iubik_kasan_flag_enabled);
+#endif
+
 	/* If KASAN is disabled via command line, don't initialize it. */
 	if (kasan_arg == KASAN_ARG_OFF)
 		return;
@@ -248,8 +255,8 @@ void __init kasan_init_hw_tags(void)
 
 	kasan_init_tags();
 
-	/* KASAN is now initialized, enable it. */
-	static_branch_enable(&kasan_flag_enabled);
+        /* KASAN is now initialized, enable it. */
+        static_branch_enable(&kasan_flag_enabled);
 
 	pr_info("KernelAddressSanitizer initialized (hw-tags, mode=%s, vmalloc=%s, stacktrace=%s)\n",
 		kasan_mode_info(),
diff --git a/mm/kasan/report.c b/mm/kasan/report.c
index fc3b9b69c9f4..6173b424debe 100644
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@ -509,8 +509,10 @@ bool kasan_report(unsigned long addr, size_t size, bool is_write,
 	struct kasan_report_info info;
 
 	if (unlikely(report_suppressed_sw()) || unlikely(!report_enabled())) {
+#if !defined(CONFIG_IUBIK)
 		ret = false;
 		goto out;
+#endif
 	}
 
 	start_report(&irq_flags, true);
@@ -528,7 +530,9 @@ bool kasan_report(unsigned long addr, size_t size, bool is_write,
 
 	end_report(&irq_flags, ptr);
 
+#if !defined(CONFIG_IUBIK)
 out:
+#endif
 	user_access_restore(ua_flags);
 
 	return ret;
diff --git a/mm/memfd.c b/mm/memfd.c
index a73af8be9c28..9cca24d2252f 100644
--- a/mm/memfd.c
+++ b/mm/memfd.c
@@ -290,7 +290,7 @@ SYSCALL_DEFINE2(memfd_create,
 	if (len > MFD_NAME_MAX_LEN + 1)
 		return -EINVAL;
 
-	name = kmalloc(len + MFD_NAME_PREFIX_LEN, GFP_KERNEL);
+	name = kmalloc(len + MFD_NAME_PREFIX_LEN, GFP_KERNEL | __GFP_IUBIK);
 	if (!name)
 		return -ENOMEM;
 
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index f2fc6a5b452a..6eb494070dae 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -2579,7 +2579,28 @@ inline void post_alloc_hook(struct page *page, unsigned int order,
 			SetPageSkipKASanPoison(page);
 		}
 	}
-	/*
+        
+        if (iubik_kasan_enabled() && !(gfp_flags & __GFP_SKIP_KASAN_UNPOISON)) {
+
+                if (gfp_flags & __GFP_IUBIK) {
+                        for (i = 0; i != 1 << order; ++i) {
+                                if (page_kasan_tag(page+i) != IUBIK_TAG_DOMU) {
+                                        iubik_set_mem_tag_range_domu(page_address(page+i), PAGE_SIZE);
+                                        page_iubik_tag_set(page+i, IUBIK_TAG_DOMU);
+                                }
+                        }
+                } else {
+                        for (i = 0; i != 1 << order; ++i) {
+                                if (page_kasan_tag(page+i) != IUBIK_TAG_DOMK) {
+                                        iubik_set_mem_tag_range_domk(page_address(page+i), PAGE_SIZE);
+                                        page_iubik_tag_set(page+i, IUBIK_TAG_DOMK);
+                                }
+                        }
+                }
+                reset_tags = false;
+        }
+	
+        /*
 	 * If memory tags have not been set by KASAN, reset the page tags to
 	 * ensure page_address() dereferencing does not fault.
 	 */
diff --git a/mm/shmem.c b/mm/shmem.c
index ee17f91ec537..f4334d794072 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -3097,7 +3097,7 @@ static int shmem_symlink(struct user_namespace *mnt_userns, struct inode *dir,
 
 	inode->i_size = len-1;
 	if (len <= SHORT_SYMLINK_LEN) {
-		inode->i_link = kmemdup(symname, len, GFP_KERNEL);
+		inode->i_link = kmemdup(symname, len, GFP_KERNEL | __GFP_IUBIK);
 		if (!inode->i_link) {
 			iput(inode);
 			return -ENOMEM;
@@ -3192,6 +3192,7 @@ static int shmem_initxattrs(struct inode *inode,
 		new_xattr->name = kmalloc(XATTR_SECURITY_PREFIX_LEN + len,
 					  GFP_KERNEL);
 		if (!new_xattr->name) {
+			kvfree(new_xattr->value);
 			kvfree(new_xattr);
 			return -ENOMEM;
 		}
diff --git a/mm/slab.h b/mm/slab.h
index 61d235eebc4e..925a4bdd751f 100644
--- a/mm/slab.h
+++ b/mm/slab.h
@@ -163,7 +163,7 @@ static inline slab_flags_t kmem_cache_flags(unsigned int object_size,
 			  SLAB_ACCOUNT)
 #elif defined(CONFIG_SLUB)
 #define SLAB_CACHE_FLAGS (SLAB_NOLEAKTRACE | SLAB_RECLAIM_ACCOUNT | \
-			  SLAB_TEMPORARY | SLAB_ACCOUNT)
+			  SLAB_TEMPORARY | SLAB_ACCOUNT | SLAB_IUBIK)
 #else
 #define SLAB_CACHE_FLAGS (SLAB_NOLEAKTRACE)
 #endif
@@ -182,6 +182,7 @@ static inline slab_flags_t kmem_cache_flags(unsigned int object_size,
 			      SLAB_NOLEAKTRACE | \
 			      SLAB_RECLAIM_ACCOUNT | \
 			      SLAB_TEMPORARY | \
+			      SLAB_IUBIK | \
 			      SLAB_ACCOUNT)
 
 bool __kmem_cache_empty(struct kmem_cache *);
diff --git a/mm/slab_common.c b/mm/slab_common.c
index 8cf667b3065e..f9e0f06981f4 100644
--- a/mm/slab_common.c
+++ b/mm/slab_common.c
@@ -771,12 +771,19 @@ struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)
 #define KMALLOC_CGROUP_NAME(sz)
 #endif
 
+#ifdef CONFIG_IUBIK
+#define KMALLOC_IUBIK_NAME(sz)	.name[KMALLOC_IUBIK] = "kmalloc-iubik-" #sz,
+#else
+#define KMALLOC_IUBIK_NAME(sz)
+#endif
+
 #define INIT_KMALLOC_INFO(__size, __short_size)			\
 {								\
 	.name[KMALLOC_NORMAL]  = "kmalloc-" #__short_size,	\
 	.name[KMALLOC_RECLAIM] = "kmalloc-rcl-" #__short_size,	\
 	KMALLOC_CGROUP_NAME(__short_size)			\
 	KMALLOC_DMA_NAME(__short_size)				\
+	KMALLOC_IUBIK_NAME(__short_size)			\
 	.size = __size,						\
 }
 
@@ -872,6 +879,8 @@ new_kmalloc_cache(int idx, enum kmalloc_cache_type type, slab_flags_t flags)
 			return;
 		}
 		flags |= SLAB_ACCOUNT;
+	} else if (IS_ENABLED(CONFIG_IUBIK) && (type == KMALLOC_IUBIK)) {
+		flags |= SLAB_IUBIK;
 	}
 
 	kmalloc_caches[type][idx] = create_kmalloc_cache(
@@ -965,14 +974,15 @@ void *kmalloc_order(size_t size, gfp_t flags, unsigned int order)
 
 	flags |= __GFP_COMP;
 	page = alloc_pages(flags, order);
-	if (likely(page)) {
-		ret = page_address(page);
-		mod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE_B,
-				      PAGE_SIZE << order);
-	}
+        if (likely(page)) {
+                ret = page_address(page);
+                mod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE_B,
+                                PAGE_SIZE << order);
+        }
 	ret = kasan_kmalloc_large(ret, size, flags);
 	/* As ret might get tagged, call kmemleak hook after KASAN. */
 	kmemleak_alloc(ret, size, 1, flags);
+	
 	return ret;
 }
 EXPORT_SYMBOL(kmalloc_order);
diff --git a/mm/slub.c b/mm/slub.c
index 361fa43129fe..366bcca5fa1e 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -1778,6 +1778,11 @@ static void *setup_object(struct kmem_cache *s, struct page *page,
 	return object;
 }
 
+#ifdef CONFIG_IUBIK_MEMBENCH
+long long slub_max_rss = 0;
+long long slub_rss = 0;
+#endif
+
 /*
  * Slab allocation and freeing
  */
@@ -1792,6 +1797,14 @@ static inline struct page *alloc_slab_page(struct kmem_cache *s,
 	else
 		page = __alloc_pages_node(node, flags, order);
 
+#ifdef CONFIG_IUBIK_MEMBENCH
+        slub_rss += 1 << order;
+        if (slub_rss > slub_max_rss) {
+                slub_max_rss = slub_rss;
+                printk("IUBIK new max RSS %lld\n", slub_max_rss);
+        }
+#endif
+
 	return page;
 }
 
@@ -1858,6 +1871,26 @@ static void *next_freelist_entry(struct kmem_cache *s, struct page *page,
 	return (char *)start + idx;
 }
 
+#ifdef CONFIG_IUBIK
+static __always_inline void *iubik_mte_set_slab_tag(slab_flags_t slabflags, void *start, unsigned int order)
+{
+        if (slabflags & SLAB_IUBIK) {
+		iubik_set_mem_tag_range_domu(start, PAGE_SIZE << order);
+                start = iubik_tag_set_domu(start);
+        } else {
+		iubik_set_mem_tag_range_domk(start, PAGE_SIZE << order);
+                start = iubik_tag_set_domk(start);
+        }
+
+	return start;
+}
+#else
+static __always_inline void *iubik_mte_set_slab_tag(slab_flags_t slabflags, void *start, unsigned int order)
+{
+        return start;
+}
+#endif
+
 /* Shuffle the single linked freelist based on a random pre-computed sequence */
 static bool shuffle_freelist(struct kmem_cache *s, struct page *page)
 {
@@ -1873,7 +1906,10 @@ static bool shuffle_freelist(struct kmem_cache *s, struct page *page)
 	pos = get_random_int() % freelist_count;
 
 	page_limit = page->objects * s->size;
-	start = fixup_red_left(s, page_address(page));
+	
+        start = page_address(page);
+        //start = iubik_mte_set_slab_tag(s->flags, start, oo_order(s->oo));
+	start = fixup_red_left(s, start);
 
 	/* First entry is used as the base of the freelist */
 	cur = next_freelist_entry(s, page, &pos, start, page_limit,
@@ -1912,6 +1948,7 @@ static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)
 	void *start, *p, *next;
 	int idx;
 	bool shuffle;
+        int i;
 
 	flags &= gfp_allowed_mask;
 
@@ -1925,6 +1962,9 @@ static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)
 	if ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))
 		alloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) & ~(__GFP_RECLAIM|__GFP_NOFAIL);
 
+        if (s->flags & SLAB_IUBIK)
+                alloc_gfp |= __GFP_IUBIK;
+
 	page = alloc_slab_page(s, alloc_gfp, node, oo);
 	if (unlikely(!page)) {
 		oo = s->min;
@@ -1949,14 +1989,15 @@ static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)
 		SetPageSlabPfmemalloc(page);
 
 	kasan_poison_slab(page);
-
+ 
 	start = page_address(page);
-
+        
 	setup_page_debug(s, page, start);
 
 	shuffle = shuffle_freelist(s, page);
 
 	if (!shuffle) {
+	        //start = iubik_mte_set_slab_tag(s->flags, start, oo_order(s->oo));
 		start = fixup_red_left(s, start);
 		start = setup_object(s, page, start);
 		page->freelist = start;
@@ -1968,6 +2009,9 @@ static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)
 		}
 		set_freepointer(s, p, NULL);
 	}
+        
+        for (i = 0; i < compound_nr(page); ++i)
+                page_kasan_tag_reset(page+i);
 
 	page->inuse = page->objects;
 	page->frozen = 1;
@@ -1977,7 +2021,7 @@ static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)
 		return NULL;
 
 	inc_slabs_node(s, page_to_nid(page), page->objects);
-
+                
 	return page;
 }
 
@@ -1996,8 +2040,13 @@ static void __free_slab(struct kmem_cache *s, struct page *page)
 {
 	int order = compound_order(page);
 	int pages = 1 << order;
+        int i;
 
-	if (kmem_cache_debug_flags(s, SLAB_CONSISTENCY_CHECKS)) {
+#ifdef CONFIG_IUBIK_MEMBENCH
+        slub_rss -= pages;
+#endif
+ 
+        if (kmem_cache_debug_flags(s, SLAB_CONSISTENCY_CHECKS)) {
 		void *p;
 
 		slab_pad_check(s, page);
@@ -2013,6 +2062,14 @@ static void __free_slab(struct kmem_cache *s, struct page *page)
 	if (current->reclaim_state)
 		current->reclaim_state->reclaimed_slab += pages;
 	unaccount_slab_page(page, order, s);
+
+        for (i = 0; i < pages; ++i) {
+                if (s->flags & SLAB_IUBIK)
+                        page_iubik_tag_set(page+i, IUBIK_TAG_DOMU);
+                else
+                        page_iubik_tag_set(page+i, IUBIK_TAG_DOMK);
+        }
+
 	__free_pages(page, order);
 }
 
@@ -4862,7 +4919,9 @@ void __init kmem_cache_init(void)
 
 	cpuhp_setup_state_nocalls(CPUHP_SLUB_DEAD, "slub:dead", NULL,
 				  slub_cpu_dead);
-
+	
+	printk("[IUBIK] Initialized\n");
+	
 	pr_info("SLUB: HWalign=%d, Order=%u-%u, MinObjects=%u, CPUs=%u, Nodes=%u\n",
 		cache_line_size(),
 		slub_min_order, slub_max_order, slub_min_objects,
diff --git a/mm/util.c b/mm/util.c
index dd9a4fdde0f0..105904a2c889 100644
--- a/mm/util.c
+++ b/mm/util.c
@@ -174,7 +174,7 @@ void *memdup_user(const void __user *src, size_t len)
 {
 	void *p;
 
-	p = kmalloc_track_caller(len, GFP_USER | __GFP_NOWARN);
+	p = kmalloc_track_caller(len, GFP_USER | __GFP_NOWARN | __GFP_IUBIK);
 	if (!p)
 		return ERR_PTR(-ENOMEM);
 
@@ -200,7 +200,7 @@ void *vmemdup_user(const void __user *src, size_t len)
 {
 	void *p;
 
-	p = kvmalloc(len, GFP_USER);
+	p = kvmalloc(len, GFP_USER | __GFP_IUBIK);
 	if (!p)
 		return ERR_PTR(-ENOMEM);
 
diff --git a/modules.bzl b/modules.bzl
index 8f8e07abcec9..7b25bfce80a1 100644
--- a/modules.bzl
+++ b/modules.bzl
@@ -38,6 +38,7 @@ _COMMON_GKI_MODULES_LIST = [
     "drivers/usb/class/cdc-acm.ko",
     "drivers/usb/serial/ftdi_sio.ko",
     "drivers/usb/serial/usbserial.ko",
+    "iubik/iubik.ko",
     "kernel/kheaders.ko",
     "lib/crypto/libarc4.ko",
     "mm/zsmalloc.ko",
@@ -67,6 +68,8 @@ _COMMON_GKI_MODULES_LIST = [
     "net/rfkill/rfkill.ko",
     "net/tipc/diag.ko",
     "net/tipc/tipc.ko",
+    "drivers/net/hamradio/6pack.ko",
+    "net/ax25/ax25.ko",
 ]
 
 # Deprecated - Use `get_gki_modules_list` function instead.
diff --git a/net/core/dev.c b/net/core/dev.c
index 8787e9c3f473..569671dafcca 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -10795,6 +10795,7 @@ void netdev_freemem(struct net_device *dev)
 {
 	char *addr = (char *)dev - dev->padded;
 
+	kvfree(dev->name);
 	kvfree(addr);
 }
 
@@ -10820,7 +10821,7 @@ struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,
 	unsigned int alloc_size;
 	struct net_device *p;
 
-	BUG_ON(strlen(name) >= sizeof(dev->name));
+	BUG_ON(strlen(name) >= sizeof__net_device__name);
 
 	if (txqs < 1) {
 		pr_err("alloc_netdev: Unable to allocate device with zero queues\n");
@@ -10844,8 +10845,15 @@ struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,
 	p = kvzalloc(alloc_size, GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL);
 	if (!p)
 		return NULL;
-
+	
 	dev = PTR_ALIGN(p, NETDEV_ALIGN);
+
+	dev->name = kvzalloc(sizeof__net_device__name, GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL | __GFP_IUBIK);
+	if (!dev->name) {
+		kvfree(p);
+		return NULL;
+	}
+
 	dev->padded = (char *)dev - (char *)p;
 
 #ifdef CONFIG_PCPU_DEV_REFCNT
diff --git a/net/core/dev_addr_lists.c b/net/core/dev_addr_lists.c
index f0cb38344126..9c20cfc97eae 100644
--- a/net/core/dev_addr_lists.c
+++ b/net/core/dev_addr_lists.c
@@ -29,6 +29,11 @@ __hw_addr_create(const unsigned char *addr, int addr_len,
 	ha = kmalloc(alloc_size, GFP_ATOMIC);
 	if (!ha)
 		return NULL;
+	ha->addr = kmalloc(sizeof__ha__addr, GFP_ATOMIC | __GFP_IUBIK);
+	if (!ha->addr) {
+		kfree(ha);
+		return NULL;
+	}
 	memcpy(ha->addr, addr, addr_len);
 	ha->type = addr_type;
 	ha->refcount = 1;
@@ -51,7 +56,7 @@ static int __hw_addr_add_ex(struct netdev_hw_addr_list *list,
 		return -EINVAL;
 
 	ha = list_first_entry(&list->list, struct netdev_hw_addr, list);
-	if (ha && !memcmp(addr, ha->addr, addr_len) &&
+	if (ha && ha->addr && !memcmp(addr, ha->addr, addr_len) &&
 	    (!addr_type || addr_type == ha->type))
 		goto found_it;
 
@@ -119,6 +124,14 @@ static int __hw_addr_add(struct netdev_hw_addr_list *list,
 				0, false);
 }
 
+static void put_ha_rcu(struct rcu_head *rcu)
+{
+	struct netdev_hw_addr *ha = container_of(rcu, struct netdev_hw_addr, rcu_head);
+
+	kfree(ha->addr);
+	kfree(ha);
+}
+
 static int __hw_addr_del_entry(struct netdev_hw_addr_list *list,
 			       struct netdev_hw_addr *ha, bool global,
 			       bool sync)
@@ -142,7 +155,7 @@ static int __hw_addr_del_entry(struct netdev_hw_addr_list *list,
 		rb_erase(&ha->node, &list->tree);
 
 	list_del_rcu(&ha->list);
-	kfree_rcu(ha, rcu_head);
+	call_rcu(&ha->rcu_head, put_ha_rcu);
 	list->count--;
 	return 0;
 }
@@ -481,7 +494,7 @@ static void __hw_addr_flush(struct netdev_hw_addr_list *list)
 	list->tree = RB_ROOT;
 	list_for_each_entry_safe(ha, tmp, &list->list, list) {
 		list_del_rcu(&ha->list);
-		kfree_rcu(ha, rcu_head);
+		call_rcu(&ha->rcu_head, put_ha_rcu);
 	}
 	list->count = 0;
 }
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index a385086091fd..dab51e169c45 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -427,9 +427,16 @@ static struct neighbour *neigh_alloc(struct neigh_table *tbl,
 	}
 
 do_alloc:
-	n = kzalloc(tbl->entry_size + dev->neigh_priv_len, GFP_ATOMIC);
+	n = kzalloc(sizeof(struct neighbour), GFP_ATOMIC);
 	if (!n)
 		goto out_entries;
+	
+	n->primary_key = kzalloc(ALIGN(tbl->key_len, NEIGH_PRIV_ALIGN) + dev->neigh_priv_len, GFP_ATOMIC | __GFP_IUBIK);
+	if (!n->primary_key){
+		kfree(n);
+		n = NULL;
+		goto out_entries;
+	}
 
 	__skb_queue_head_init(&n->arp_queue);
 	rwlock_init(&n->lock);
@@ -816,6 +823,14 @@ static inline void neigh_parms_put(struct neigh_parms *parms)
 		neigh_parms_destroy(parms);
 }
 
+static void put_neigh_rcu(struct rcu_head *rcu)
+{
+	struct neighbour *neigh = container_of(rcu, struct neighbour, rcu);
+
+	kfree(neigh->primary_key);
+	kfree(neigh);
+}
+
 /*
  *	neighbour must already be out of the table;
  *
@@ -849,7 +864,7 @@ void neigh_destroy(struct neighbour *neigh)
 	neigh_dbg(2, "neigh %p is destroyed\n", neigh);
 
 	atomic_dec(&neigh->tbl->entries);
-	kfree_rcu(neigh, rcu);
+	call_rcu(&neigh->rcu, put_neigh_rcu);
 }
 EXPORT_SYMBOL(neigh_destroy);
 
diff --git a/net/core/netpoll.c b/net/core/netpoll.c
index 47a86da6ab98..b53fca77ee2b 100644
--- a/net/core/netpoll.c
+++ b/net/core/netpoll.c
@@ -763,10 +763,10 @@ int netpoll_setup(struct netpoll *np)
 
 				read_lock_bh(&idev->lock);
 				list_for_each_entry(ifp, &idev->addr_list, if_list) {
-					if (!!(ipv6_addr_type(&ifp->addr) & IPV6_ADDR_LINKLOCAL) !=
+					if (!!(ipv6_addr_type(ifp->addr) & IPV6_ADDR_LINKLOCAL) !=
 					    !!(ipv6_addr_type(&np->remote_ip.in6) & IPV6_ADDR_LINKLOCAL))
 						continue;
-					np->local_ip.in6 = ifp->addr;
+					np->local_ip.in6 = *ifp->addr;
 					err = 0;
 					break;
 				}
diff --git a/net/core/pktgen.c b/net/core/pktgen.c
index a539f26fe4be..3d767c2cb85b 100644
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@ -2196,7 +2196,7 @@ static void pktgen_setup_inject(struct pktgen_dev *pkt_dev)
 				list_for_each_entry(ifp, &idev->addr_list, if_list) {
 					if ((ifp->scope & IFA_LINK) &&
 					    !(ifp->flags & IFA_F_TENTATIVE)) {
-						pkt_dev->cur_in6_saddr = ifp->addr;
+						pkt_dev->cur_in6_saddr = *ifp->addr;
 						err = 0;
 						break;
 					}
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 1b71e5c582bb..120034db7780 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -3687,7 +3687,7 @@ static int rtnl_alt_ifname(int cmd, struct net_device *dev, struct nlattr *attr,
 		}
 	}
 
-	alt_ifname = nla_strdup(attr, GFP_KERNEL_ACCOUNT);
+	alt_ifname = nla_strdup(attr, GFP_KERNEL_ACCOUNT | __GFP_IUBIK);
 	if (!alt_ifname)
 		return -ENOMEM;
 
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index de2b493c604e..963b1280cff8 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -210,9 +210,9 @@ static void __build_skb_around(struct sk_buff *skb, void *data,
 
 	/* make sure we initialize shinfo sequentially */
 	shinfo = skb_shinfo(skb);
+	iubik_set_mem_tag_range_domk(shinfo, SKB_DATA_ALIGN(sizeof(struct skb_shared_info)));
 	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
-
 	skb_set_kcov_handle(skb, kcov_common_handle());
 }
 
@@ -355,14 +355,14 @@ static void *kmalloc_reserve(size_t size, gfp_t flags, int node,
 	 * to the reserves, fail.
 	 */
 	obj = kmalloc_node_track_caller(size,
-					flags | __GFP_NOMEMALLOC | __GFP_NOWARN,
+					flags | __GFP_NOMEMALLOC | __GFP_NOWARN | __GFP_IUBIK,
 					node);
 	if (obj || !(gfp_pfmemalloc_allowed(flags)))
 		goto out;
 
 	/* Try again but now we are using pfmemalloc reserves */
 	ret_pfmemalloc = true;
-	obj = kmalloc_node_track_caller(size, flags, node);
+	obj = kmalloc_node_track_caller(size, flags | __GFP_IUBIK, node);
 
 out:
 	if (pfmemalloc)
@@ -653,6 +653,7 @@ static void skb_free_head(struct sk_buff *skb)
 			return;
 		skb_free_frag(head);
 	} else {
+	        iubik_set_mem_tag_range_domu(skb_shinfo(skb), SKB_DATA_ALIGN(sizeof(struct skb_shared_info)));
 		kfree(head);
 	}
 }
@@ -1693,6 +1694,7 @@ int pskb_expand_head(struct sk_buff *skb, int nhead, int ntail,
 	int size = osize + nhead + ntail;
 	long off;
 	u8 *data;
+	struct skb_shared_info *shinfo;
 
 	BUG_ON(nhead < 0);
 
@@ -1713,8 +1715,10 @@ int pskb_expand_head(struct sk_buff *skb, int nhead, int ntail,
 	 */
 	memcpy(data + nhead, skb->head, skb_tail_pointer(skb) - skb->head);
 
-	memcpy((struct skb_shared_info *)(data + size),
-	       skb_shinfo(skb),
+	shinfo = (struct skb_shared_info *)iubik_tag_set_domk(data + size);
+	iubik_set_mem_tag_range_domk(shinfo, SKB_DATA_ALIGN(sizeof(struct skb_shared_info)));
+	
+	memcpy(shinfo, skb_shinfo(skb),
 	       offsetof(struct skb_shared_info, frags[skb_shinfo(skb)->nr_frags]));
 
 	/*
@@ -1766,6 +1770,7 @@ int pskb_expand_head(struct sk_buff *skb, int nhead, int ntail,
 	return 0;
 
 nofrags:
+	iubik_set_mem_tag_range_domu(shinfo, SKB_DATA_ALIGN(sizeof(struct skb_shared_info)));
 	kfree(data);
 nodata:
 	return -ENOMEM;
@@ -6180,6 +6185,7 @@ static int pskb_carve_inside_header(struct sk_buff *skb, const u32 off,
 	int size = skb_end_offset(skb);
 	int new_hlen = headlen - off;
 	u8 *data;
+	struct skb_shared_info *shinfo;
 
 	size = SKB_DATA_ALIGN(size);
 
@@ -6197,13 +6203,16 @@ static int pskb_carve_inside_header(struct sk_buff *skb, const u32 off,
 	skb_copy_from_linear_data_offset(skb, off, data, new_hlen);
 	skb->len -= off;
 
-	memcpy((struct skb_shared_info *)(data + size),
-	       skb_shinfo(skb),
-	       offsetof(struct skb_shared_info,
-			frags[skb_shinfo(skb)->nr_frags]));
+	shinfo = (struct skb_shared_info *)iubik_tag_set_domk(data + size);
+	iubik_set_mem_tag_range_domk(shinfo, SKB_DATA_ALIGN(sizeof(struct skb_shared_info)));
+	
+	memcpy(shinfo, skb_shinfo(skb),
+	       offsetof(struct skb_shared_info, frags[skb_shinfo(skb)->nr_frags]));
 	if (skb_cloned(skb)) {
 		/* drop the old head gracefully */
 		if (skb_orphan_frags(skb, gfp_mask)) {
+			iubik_set_mem_tag_range_domu(shinfo, 
+				SKB_DATA_ALIGN(sizeof(struct skb_shared_info)));
 			kfree(data);
 			return -ENOMEM;
 		}
@@ -6313,13 +6322,17 @@ static int pskb_carve_inside_nonlinear(struct sk_buff *skb, const u32 off,
 
 	size = SKB_WITH_OVERHEAD(ksize(data));
 
-	memcpy((struct skb_shared_info *)(data + size),
-	       skb_shinfo(skb), offsetof(struct skb_shared_info, frags[0]));
+	shinfo = (struct skb_shared_info *)iubik_tag_set_domk(data + size);
+	iubik_set_mem_tag_range_domk(shinfo, SKB_DATA_ALIGN(sizeof(struct skb_shared_info)));
+	
+	memcpy(shinfo, skb_shinfo(skb), offsetof(struct skb_shared_info, frags[0]));
+	
 	if (skb_orphan_frags(skb, gfp_mask)) {
+		iubik_set_mem_tag_range_domu(shinfo, SKB_DATA_ALIGN(sizeof(struct skb_shared_info)));
 		kfree(data);
 		return -ENOMEM;
 	}
-	shinfo = (struct skb_shared_info *)(data + size);
+	
 	for (i = 0; i < nfrags; i++) {
 		int fsize = skb_frag_size(&skb_shinfo(skb)->frags[i]);
 
@@ -6352,6 +6365,7 @@ static int pskb_carve_inside_nonlinear(struct sk_buff *skb, const u32 off,
 		/* skb_frag_unref() is not needed here as shinfo->nr_frags = 0. */
 		if (skb_has_frag_list(skb))
 			kfree_skb_list(skb_shinfo(skb)->frag_list);
+		iubik_set_mem_tag_range_domu(shinfo, SKB_DATA_ALIGN(sizeof(struct skb_shared_info)));
 		kfree(data);
 		return -ENOMEM;
 	}
diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c
index c511751c2f41..b68263221f34 100644
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -215,7 +215,15 @@ static void devinet_sysctl_unregister(struct in_device *idev)
 
 static struct in_ifaddr *inet_alloc_ifa(void)
 {
-	return kzalloc(sizeof(struct in_ifaddr), GFP_KERNEL_ACCOUNT);
+	struct in_ifaddr *ifa = kzalloc(sizeof(struct in_ifaddr), GFP_KERNEL_ACCOUNT);
+	if (!ifa)
+		return NULL;
+	ifa->ifa_label = kzalloc(sizeof__in_ifaddr__ifa_label, GFP_KERNEL_ACCOUNT | __GFP_IUBIK);
+	if (!ifa->ifa_label) {
+		kfree(ifa);
+		return NULL;
+	}
+	return ifa;
 }
 
 static void inet_rcu_free_ifa(struct rcu_head *head)
@@ -223,6 +231,7 @@ static void inet_rcu_free_ifa(struct rcu_head *head)
 	struct in_ifaddr *ifa = container_of(head, struct in_ifaddr, rcu_head);
 	if (ifa->ifa_dev)
 		in_dev_put(ifa->ifa_dev);
+	kfree(ifa->ifa_label);
 	kfree(ifa);
 }
 
diff --git a/net/ipv4/ip_tunnel.c b/net/ipv4/ip_tunnel.c
index 426dc910aaf8..49beef2ed7eb 100644
--- a/net/ipv4/ip_tunnel.c
+++ b/net/ipv4/ip_tunnel.c
@@ -687,7 +687,7 @@ void ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,
 			if (!neigh)
 				goto tx_error;
 
-			addr6 = (const struct in6_addr *)&neigh->primary_key;
+			addr6 = (const struct in6_addr *)neigh->primary_key;
 			addr_type = ipv6_addr_type(addr6);
 
 			if (addr_type == IPV6_ADDR_ANY) {
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index 80e9cdcf43ca..4c38fd996088 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -386,6 +386,11 @@ static struct inet6_dev *ipv6_add_dev(struct net_device *dev)
 	ndev = kzalloc(sizeof(struct inet6_dev), GFP_KERNEL);
 	if (!ndev)
 		return ERR_PTR(err);
+	ndev->token = kzalloc(sizeof(struct in6_addr), GFP_KERNEL_IUBIK);
+	if (!ndev->token) {
+		kfree(ndev);
+		return ERR_PTR(err);
+	}
 
 	rwlock_init(&ndev->lock);
 	ndev->dev = dev;
@@ -400,6 +405,7 @@ static struct inet6_dev *ipv6_add_dev(struct net_device *dev)
 	ndev->ra_mtu = 0;
 	ndev->nd_parms = neigh_parms_alloc(dev, &nd_tbl);
 	if (!ndev->nd_parms) {
+		kfree(ndev->token);
 		kfree(ndev);
 		return ERR_PTR(err);
 	}
@@ -413,6 +419,7 @@ static struct inet6_dev *ipv6_add_dev(struct net_device *dev)
 			   __func__);
 		neigh_parms_release(&nd_tbl, ndev->nd_parms);
 		dev_put(dev);
+		kfree(ndev->token);
 		kfree(ndev);
 		return ERR_PTR(err);
 	}
@@ -446,7 +453,7 @@ static struct inet6_dev *ipv6_add_dev(struct net_device *dev)
 		ndev->cnf.use_tempaddr = -1;
 	}
 
-	ndev->token = in6addr_any;
+	*ndev->token = in6addr_any;
 
 	if (netif_running(dev) && addrconf_link_ready(dev))
 		ndev->if_flags |= IF_READY;
@@ -968,6 +975,14 @@ static int addrconf_fixup_linkdown(struct ctl_table *table, int *p, int newf)
 
 #endif
 
+static void put_ifa_rcu(struct rcu_head *rcu)
+{
+	struct inet6_ifaddr *ifa = container_of(rcu, struct inet6_ifaddr, rcu);
+
+	kfree(ifa->addr);
+	kfree(ifa);
+} 
+
 /* Nobody refers to this ifaddr, destroy it */
 void inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp)
 {
@@ -988,14 +1003,14 @@ void inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp)
 		return;
 	}
 
-	kfree_rcu(ifp, rcu);
+	call_rcu(&ifp->rcu, put_ifa_rcu);
 }
 
 static void
 ipv6_link_dev_addr(struct inet6_dev *idev, struct inet6_ifaddr *ifp)
 {
 	struct list_head *p;
-	int ifp_scope = ipv6_addr_src_scope(&ifp->addr);
+	int ifp_scope = ipv6_addr_src_scope(ifp->addr);
 
 	/*
 	 * Each device address list is sorted in order of scope -
@@ -1004,7 +1019,7 @@ ipv6_link_dev_addr(struct inet6_dev *idev, struct inet6_ifaddr *ifp)
 	list_for_each(p, &idev->addr_list) {
 		struct inet6_ifaddr *ifa
 			= list_entry(p, struct inet6_ifaddr, if_list);
-		if (ifp_scope >= ipv6_addr_src_scope(&ifa->addr))
+		if (ifp_scope >= ipv6_addr_src_scope(ifa->addr))
 			break;
 	}
 
@@ -1026,7 +1041,7 @@ static bool ipv6_chk_same_addr(struct net *net, const struct in6_addr *addr,
 	hlist_for_each_entry(ifp, &inet6_addr_lst[hash], addr_lst) {
 		if (!net_eq(dev_net(ifp->idev->dev), net))
 			continue;
-		if (ipv6_addr_equal(&ifp->addr, addr)) {
+		if (ipv6_addr_equal(ifp->addr, addr)) {
 			if (!dev || ifp->idev->dev == dev)
 				return true;
 		}
@@ -1036,13 +1051,13 @@ static bool ipv6_chk_same_addr(struct net *net, const struct in6_addr *addr,
 
 static int ipv6_add_addr_hash(struct net_device *dev, struct inet6_ifaddr *ifa)
 {
-	unsigned int hash = inet6_addr_hash(dev_net(dev), &ifa->addr);
+	unsigned int hash = inet6_addr_hash(dev_net(dev), ifa->addr);
 	int err = 0;
 
 	spin_lock(&addrconf_hash_lock);
 
 	/* Ignore adding duplicate addresses on an interface */
-	if (ipv6_chk_same_addr(dev_net(dev), &ifa->addr, dev, hash)) {
+	if (ipv6_chk_same_addr(dev_net(dev), ifa->addr, dev, hash)) {
 		netdev_dbg(dev, "ipv6_add_addr: already assigned\n");
 		err = -EEXIST;
 	} else {
@@ -1106,6 +1121,11 @@ ipv6_add_addr(struct inet6_dev *idev, struct ifa6_config *cfg,
 		err = -ENOBUFS;
 		goto out;
 	}
+	ifa->addr = kzalloc(sizeof(struct in6_addr), gfp_flags | __GFP_ACCOUNT | __GFP_IUBIK);
+	if (!ifa->addr) {
+		err = -ENOBUFS;
+		goto out;
+	}
 
 	f6i = addrconf_f6i_alloc(net, idev, cfg->pfx, false, gfp_flags);
 	if (IS_ERR(f6i)) {
@@ -1116,7 +1136,7 @@ ipv6_add_addr(struct inet6_dev *idev, struct ifa6_config *cfg,
 
 	neigh_parms_data_state_setall(idev->nd_parms);
 
-	ifa->addr = *cfg->pfx;
+	*ifa->addr = *cfg->pfx;
 	if (cfg->peer_pfx)
 		ifa->peer_addr = *cfg->peer_pfx;
 
@@ -1174,6 +1194,8 @@ ipv6_add_addr(struct inet6_dev *idev, struct ifa6_config *cfg,
 		if (ifa) {
 			if (ifa->idev)
 				in6_dev_put(ifa->idev);
+			if (ifa->addr)
+				kfree(ifa->addr);
 			kfree(ifa);
 		}
 		ifa = ERR_PTR(err);
@@ -1220,7 +1242,7 @@ check_cleanup_prefix_route(struct inet6_ifaddr *ifp, unsigned long *expires)
 		if (ifa == ifp)
 			continue;
 		if (ifa->prefix_len != ifp->prefix_len ||
-		    !ipv6_prefix_equal(&ifa->addr, &ifp->addr,
+		    !ipv6_prefix_equal(ifa->addr, ifp->addr,
 				       ifp->prefix_len))
 			continue;
 		if (ifa->flags & (IFA_F_PERMANENT | IFA_F_NOPREFIXROUTE))
@@ -1250,7 +1272,7 @@ cleanup_prefix_route(struct inet6_ifaddr *ifp, unsigned long expires,
 {
 	struct fib6_info *f6i;
 
-	f6i = addrconf_get_prefix_route(del_peer ? &ifp->peer_addr : &ifp->addr,
+	f6i = addrconf_get_prefix_route(del_peer ? &ifp->peer_addr : ifp->addr,
 					ifp->prefix_len,
 					ifp->idev->dev, 0, RTF_DEFAULT, true);
 	if (f6i) {
@@ -1359,7 +1381,7 @@ static int ipv6_create_tempaddr(struct inet6_ifaddr *ifp, bool block)
 		goto out;
 	}
 	in6_ifa_hold(ifp);
-	memcpy(addr.s6_addr, ifp->addr.s6_addr, 8);
+	memcpy(addr.s6_addr, ifp->addr->s6_addr, 8);
 	ipv6_gen_rnd_iid(&addr);
 
 	age = (now - ifp->tstamp) / HZ;
@@ -1549,7 +1571,7 @@ static int ipv6_get_saddr_eval(struct net *net,
 		break;
 	case IPV6_SADDR_RULE_LOCAL:
 		/* Rule 1: Prefer same address */
-		ret = ipv6_addr_equal(&score->ifa->addr, dst->addr);
+		ret = ipv6_addr_equal(score->ifa->addr, dst->addr);
 		break;
 	case IPV6_SADDR_RULE_SCOPE:
 		/* Rule 2: Prefer appropriate scope
@@ -1608,7 +1630,7 @@ static int ipv6_get_saddr_eval(struct net *net,
 	case IPV6_SADDR_RULE_LABEL:
 		/* Rule 6: Prefer matching label */
 		ret = ipv6_addr_label(net,
-				      &score->ifa->addr, score->addr_type,
+				      score->ifa->addr, score->addr_type,
 				      score->ifa->idev->dev->ifindex) == dst->label;
 		break;
 	case IPV6_SADDR_RULE_PRIVACY:
@@ -1626,12 +1648,12 @@ static int ipv6_get_saddr_eval(struct net *net,
 		/* Rule 8-: Prefer ORCHID vs ORCHID or
 		 *	    non-ORCHID vs non-ORCHID
 		 */
-		ret = !(ipv6_addr_orchid(&score->ifa->addr) ^
+		ret = !(ipv6_addr_orchid(score->ifa->addr) ^
 			ipv6_addr_orchid(dst->addr));
 		break;
 	case IPV6_SADDR_RULE_PREFIX:
 		/* Rule 8: Use longest matching prefix */
-		ret = ipv6_addr_diff(&score->ifa->addr, dst->addr);
+		ret = ipv6_addr_diff(score->ifa->addr, dst->addr);
 		if (ret > score->ifa->prefix_len)
 			ret = score->ifa->prefix_len;
 		score->matchlen = ret;
@@ -1680,7 +1702,7 @@ static int __ipv6_dev_get_saddr(struct net *net,
 		    (!(score->ifa->flags & IFA_F_OPTIMISTIC)))
 			continue;
 
-		score->addr_type = __ipv6_addr_type(&score->ifa->addr);
+		score->addr_type = __ipv6_addr_type(score->ifa->addr);
 
 		if (unlikely(score->addr_type == IPV6_ADDR_ANY ||
 			     score->addr_type & IPV6_ADDR_MULTICAST)) {
@@ -1840,7 +1862,7 @@ int ipv6_dev_get_saddr(struct net *net, const struct net_device *dst_dev,
 	if (!hiscore->ifa)
 		ret = -EADDRNOTAVAIL;
 	else
-		*saddr = hiscore->ifa->addr;
+		*saddr = *hiscore->ifa->addr;
 
 	rcu_read_unlock();
 	return ret;
@@ -1858,7 +1880,7 @@ static int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,
 			break;
 		if (ifp->scope == IFA_LINK &&
 		    !(ifp->flags & banned_flags)) {
-			*addr = ifp->addr;
+			*addr = *ifp->addr;
 			err = 0;
 			break;
 		}
@@ -1942,7 +1964,7 @@ __ipv6_chk_addr_and_flags(struct net *net, const struct in6_addr *addr,
 		ifp_flags = (ifp->flags&IFA_F_OPTIMISTIC)
 			    ? (ifp->flags&~IFA_F_TENTATIVE)
 			    : ifp->flags;
-		if (ipv6_addr_equal(&ifp->addr, addr) &&
+		if (ipv6_addr_equal(ifp->addr, addr) &&
 		    !(ifp_flags&banned_flags) &&
 		    (!dev || ndev == dev ||
 		     !(ifp->scope&(IFA_LINK|IFA_HOST) || strict))) {
@@ -1979,7 +2001,7 @@ bool ipv6_chk_custom_prefix(const struct in6_addr *addr,
 	idev = __in6_dev_get(dev);
 	if (idev) {
 		list_for_each_entry_rcu(ifa, &idev->addr_list, if_list) {
-			ret = ipv6_prefix_equal(addr, &ifa->addr, prefix_len);
+			ret = ipv6_prefix_equal(addr, ifa->addr, prefix_len);
 			if (ret)
 				break;
 		}
@@ -2001,7 +2023,7 @@ int ipv6_chk_prefix(const struct in6_addr *addr, struct net_device *dev)
 	idev = __in6_dev_get(dev);
 	if (idev) {
 		list_for_each_entry_rcu(ifa, &idev->addr_list, if_list) {
-			onlink = ipv6_prefix_equal(addr, &ifa->addr,
+			onlink = ipv6_prefix_equal(addr, ifa->addr,
 						   ifa->prefix_len);
 			if (onlink)
 				break;
@@ -2038,7 +2060,7 @@ struct inet6_ifaddr *ipv6_get_ifaddr(struct net *net, const struct in6_addr *add
 	hlist_for_each_entry_rcu(ifp, &inet6_addr_lst[hash], addr_lst) {
 		if (!net_eq(dev_net(ifp->idev->dev), net))
 			continue;
-		if (ipv6_addr_equal(&ifp->addr, addr)) {
+		if (ipv6_addr_equal(ifp->addr, addr)) {
 			if (!dev || ifp->idev->dev == dev ||
 			    !(ifp->scope&(IFA_LINK|IFA_HOST) || strict)) {
 				result = ifp;
@@ -2112,7 +2134,7 @@ void addrconf_dad_failure(struct sk_buff *skb, struct inet6_ifaddr *ifp)
 	}
 
 	net_info_ratelimited("%s: IPv6 duplicate address %pI6c used by %pM detected!\n",
-			     ifp->idev->dev->name, &ifp->addr, eth_hdr(skb)->h_source);
+			     ifp->idev->dev->name, ifp->addr, eth_hdr(skb)->h_source);
 
 	spin_lock_bh(&ifp->lock);
 
@@ -2135,7 +2157,7 @@ void addrconf_dad_failure(struct sk_buff *skb, struct inet6_ifaddr *ifp)
 			goto errdad;
 		}
 
-		new_addr = ifp->addr;
+		new_addr = *ifp->addr;
 		if (ipv6_generate_stable_address(&new_addr, retries,
 						 idev))
 			goto errdad;
@@ -2206,7 +2228,7 @@ static void addrconf_join_anycast(struct inet6_ifaddr *ifp)
 
 	if (ifp->prefix_len >= 127) /* RFC 6164 */
 		return;
-	ipv6_addr_prefix(&addr, &ifp->addr, ifp->prefix_len);
+	ipv6_addr_prefix(&addr, ifp->addr, ifp->prefix_len);
 	if (ipv6_addr_any(&addr))
 		return;
 	__ipv6_dev_ac_inc(ifp->idev, &addr);
@@ -2219,7 +2241,7 @@ static void addrconf_leave_anycast(struct inet6_ifaddr *ifp)
 
 	if (ifp->prefix_len >= 127) /* RFC 6164 */
 		return;
-	ipv6_addr_prefix(&addr, &ifp->addr, ifp->prefix_len);
+	ipv6_addr_prefix(&addr, ifp->addr, ifp->prefix_len);
 	if (ipv6_addr_any(&addr))
 		return;
 	__ipv6_dev_ac_dec(ifp->idev, &addr);
@@ -2354,7 +2376,7 @@ static int ipv6_inherit_eui64(u8 *eui, struct inet6_dev *idev)
 		if (ifp->scope > IFA_LINK)
 			break;
 		if (ifp->scope == IFA_LINK && !(ifp->flags&IFA_F_TENTATIVE)) {
-			memcpy(eui, ifp->addr.s6_addr+8, 8);
+			memcpy(eui, ifp->addr->s6_addr+8, 8);
 			err = 0;
 			break;
 		}
@@ -2825,10 +2847,10 @@ void addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len, bool sllao)
 		if (pinfo->prefix_len == 64) {
 			memcpy(&addr, &pinfo->prefix, 8);
 
-			if (!ipv6_addr_any(&in6_dev->token)) {
+			if (!ipv6_addr_any(in6_dev->token)) {
 				read_lock_bh(&in6_dev->lock);
 				memcpy(addr.s6_addr + 8,
-				       in6_dev->token.s6_addr + 8, 8);
+				       in6_dev->token->s6_addr + 8, 8);
 				read_unlock_bh(&in6_dev->lock);
 				tokenized = true;
 			} else if (is_addr_mode_generate_stable(in6_dev) &&
@@ -3004,7 +3026,7 @@ static int inet6_addr_add(struct net *net, int ifindex,
 	ifp = ipv6_add_addr(idev, cfg, true, extack);
 	if (!IS_ERR(ifp)) {
 		if (!(cfg->ifa_flags & IFA_F_NOPREFIXROUTE)) {
-			addrconf_prefix_route(&ifp->addr, ifp->prefix_len,
+			addrconf_prefix_route(ifp->addr, ifp->prefix_len,
 					      ifp->rt_priority, dev, expires,
 					      flags, GFP_KERNEL);
 		}
@@ -3055,7 +3077,7 @@ static int inet6_addr_del(struct net *net, int ifindex, u32 ifa_flags,
 	read_lock_bh(&idev->lock);
 	list_for_each_entry(ifp, &idev->addr_list, if_list) {
 		if (ifp->prefix_len == plen &&
-		    ipv6_addr_equal(pfx, &ifp->addr)) {
+		    ipv6_addr_equal(pfx, ifp->addr)) {
 			in6_ifa_hold(ifp);
 			read_unlock_bh(&idev->lock);
 
@@ -3246,7 +3268,7 @@ void addrconf_add_linklocal(struct inet6_dev *idev,
 
 	ifp = ipv6_add_addr(idev, &cfg, true, NULL);
 	if (!IS_ERR(ifp)) {
-		addrconf_prefix_route(&ifp->addr, ifp->prefix_len, 0, idev->dev,
+		addrconf_prefix_route(ifp->addr, ifp->prefix_len, 0, idev->dev,
 				      0, 0, GFP_ATOMIC);
 		addrconf_dad_start(ifp);
 		in6_ifa_put(ifp);
@@ -3514,7 +3536,7 @@ static int fixup_permanent_addr(struct net *net,
 	if (!ifp->rt || !ifp->rt->fib6_node) {
 		struct fib6_info *f6i, *prev;
 
-		f6i = addrconf_f6i_alloc(net, idev, &ifp->addr, false,
+		f6i = addrconf_f6i_alloc(net, idev, ifp->addr, false,
 					 GFP_ATOMIC);
 		if (IS_ERR(f6i))
 			return PTR_ERR(f6i);
@@ -3529,7 +3551,7 @@ static int fixup_permanent_addr(struct net *net,
 	}
 
 	if (!(ifp->flags & IFA_F_NOPREFIXROUTE)) {
-		addrconf_prefix_route(&ifp->addr, ifp->prefix_len,
+		addrconf_prefix_route(ifp->addr, ifp->prefix_len,
 				      ifp->rt_priority, idev->dev, 0, 0,
 				      GFP_ATOMIC);
 	}
@@ -3560,7 +3582,7 @@ static void addrconf_permanent_addr(struct net *net, struct net_device *dev)
 			write_lock_bh(&idev->lock);
 
 			net_info_ratelimited("%s: Failed to add prefix route for address %pI6c; dropping\n",
-					     idev->dev->name, &ifp->addr);
+					     idev->dev->name, ifp->addr);
 		}
 	}
 
@@ -3828,7 +3850,7 @@ static int addrconf_ifdown(struct net_device *dev, bool unregister)
 				 */
 				if (!keep_addr ||
 				    !(ifa->flags & IFA_F_PERMANENT) ||
-				    addr_is_local(&ifa->addr)) {
+				    addr_is_local(ifa->addr)) {
 					hlist_del_init_rcu(&ifa->addr_lst);
 					goto restart;
 				}
@@ -3880,7 +3902,7 @@ static int addrconf_ifdown(struct net_device *dev, bool unregister)
 		addrconf_del_dad_work(ifa);
 
 		keep = keep_addr && (ifa->flags & IFA_F_PERMANENT) &&
-			!addr_is_local(&ifa->addr);
+			!addr_is_local(ifa->addr);
 
 		spin_lock_bh(&ifa->lock);
 
@@ -3909,7 +3931,7 @@ static int addrconf_ifdown(struct net_device *dev, bool unregister)
 		} else {
 			if (idev->cnf.forwarding)
 				addrconf_leave_anycast(ifa);
-			addrconf_leave_solict(ifa->idev, &ifa->addr);
+			addrconf_leave_solict(ifa->idev, ifa->addr);
 		}
 
 		if (!keep) {
@@ -4021,9 +4043,9 @@ static void addrconf_dad_begin(struct inet6_ifaddr *ifp)
 	bool bump_id, notify = false;
 	struct net *net;
 
-	addrconf_join_solict(dev, &ifp->addr);
+	addrconf_join_solict(dev, ifp->addr);
 
-	prandom_seed((__force u32) ifp->addr.s6_addr32[3]);
+	prandom_seed((__force u32) ifp->addr->s6_addr32[3]);
 
 	read_lock_bh(&idev->lock);
 	spin_lock(&ifp->lock);
@@ -4135,7 +4157,7 @@ static void addrconf_dad_work(struct work_struct *w)
 			addr.s6_addr32[1] = 0;
 
 			if (!ipv6_generate_eui64(addr.s6_addr + 8, idev->dev) &&
-			    ipv6_addr_equal(&ifp->addr, &addr)) {
+			    ipv6_addr_equal(ifp->addr, &addr)) {
 				/* DAD failed for link-local based on MAC */
 				idev->cnf.disable_ipv6 = 1;
 
@@ -4202,8 +4224,8 @@ static void addrconf_dad_work(struct work_struct *w)
 	write_unlock_bh(&idev->lock);
 
 	/* send a neighbour solicitation for our addr */
-	addrconf_addr_solict_mult(&ifp->addr, &mcaddr);
-	ndisc_send_ns(ifp->idev->dev, &ifp->addr, &mcaddr, &in6addr_any,
+	addrconf_addr_solict_mult(ifp->addr, &mcaddr);
+	ndisc_send_ns(ifp->idev->dev, ifp->addr, &mcaddr, &in6addr_any,
 		      ifp->dad_nonce);
 out:
 	in6_ifa_put(ifp);
@@ -4266,7 +4288,7 @@ static void addrconf_dad_completed(struct inet6_ifaddr *ifp, bool bump_id,
 	if (send_na &&
 	    (ifp->idev->cnf.ndisc_notify ||
 	     dev_net(dev)->ipv6.devconf_all->ndisc_notify)) {
-		ndisc_send_na(dev, &in6addr_linklocal_allnodes, &ifp->addr,
+		ndisc_send_na(dev, &in6addr_linklocal_allnodes, ifp->addr,
 			      /*router=*/ !!ifp->idev->cnf.forwarding,
 			      /*solicited=*/ false, /*override=*/ true,
 			      /*inc_opt=*/ true);
@@ -4413,7 +4435,7 @@ static int if6_seq_show(struct seq_file *seq, void *v)
 {
 	struct inet6_ifaddr *ifp = (struct inet6_ifaddr *)v;
 	seq_printf(seq, "%pi6 %02x %02x %02x %02x %8s\n",
-		   &ifp->addr,
+		   ifp->addr,
 		   ifp->idev->dev->ifindex,
 		   ifp->prefix_len,
 		   ifp->scope,
@@ -4470,7 +4492,7 @@ int ipv6_chk_home_addr(struct net *net, const struct in6_addr *addr)
 	hlist_for_each_entry_rcu(ifp, &inet6_addr_lst[hash], addr_lst) {
 		if (!net_eq(dev_net(ifp->idev->dev), net))
 			continue;
-		if (ipv6_addr_equal(&ifp->addr, addr) &&
+		if (ipv6_addr_equal(ifp->addr, addr) &&
 		    (ifp->flags & IFA_F_HOMEADDRESS)) {
 			ret = 1;
 			break;
@@ -4511,7 +4533,7 @@ int ipv6_chk_rpl_srh_loop(struct net *net, const struct in6_addr *segs,
 			if (!net_eq(dev_net(ifp->idev->dev), net))
 				continue;
 
-			if (ipv6_addr_equal(&ifp->addr, addr)) {
+			if (ipv6_addr_equal(ifp->addr, addr)) {
 				hash_found = true;
 				break;
 			}
@@ -4734,7 +4756,7 @@ static int modify_prefix_route(struct inet6_ifaddr *ifp,
 	struct fib6_info *f6i;
 	u32 prio;
 
-	f6i = addrconf_get_prefix_route(modify_peer ? &ifp->peer_addr : &ifp->addr,
+	f6i = addrconf_get_prefix_route(modify_peer ? &ifp->peer_addr : ifp->addr,
 					ifp->prefix_len,
 					ifp->idev->dev, 0, RTF_DEFAULT, true);
 	if (!f6i)
@@ -4746,7 +4768,7 @@ static int modify_prefix_route(struct inet6_ifaddr *ifp,
 		ip6_del_rt(dev_net(ifp->idev->dev), f6i, false);
 
 		/* add new one */
-		addrconf_prefix_route(modify_peer ? &ifp->peer_addr : &ifp->addr,
+		addrconf_prefix_route(modify_peer ? &ifp->peer_addr : ifp->addr,
 				      ifp->prefix_len,
 				      ifp->rt_priority, ifp->idev->dev,
 				      expires, flags, GFP_KERNEL);
@@ -4838,7 +4860,7 @@ static int inet6_addr_modify(struct inet6_ifaddr *ifp, struct ifa6_config *cfg)
 
 		/* prefix route could have been deleted; if so restore it */
 		if (rc == -ENOENT) {
-			addrconf_prefix_route(&ifp->addr, ifp->prefix_len,
+			addrconf_prefix_route(ifp->addr, ifp->prefix_len,
 					      ifp->rt_priority, ifp->idev->dev,
 					      expires, flags, GFP_KERNEL);
 		}
@@ -5077,11 +5099,11 @@ static int inet6_fill_ifaddr(struct sk_buff *skb, struct inet6_ifaddr *ifa,
 	spin_unlock_bh(&ifa->lock);
 
 	if (!ipv6_addr_any(&ifa->peer_addr)) {
-		if (nla_put_in6_addr(skb, IFA_LOCAL, &ifa->addr) < 0 ||
+		if (nla_put_in6_addr(skb, IFA_LOCAL, ifa->addr) < 0 ||
 		    nla_put_in6_addr(skb, IFA_ADDRESS, &ifa->peer_addr) < 0)
 			goto error;
 	} else
-		if (nla_put_in6_addr(skb, IFA_ADDRESS, &ifa->addr) < 0)
+		if (nla_put_in6_addr(skb, IFA_ADDRESS, ifa->addr) < 0)
 			goto error;
 
 	if (ifa->rt_priority &&
@@ -5731,7 +5753,7 @@ static int inet6_fill_ifla6_attrs(struct sk_buff *skb, struct inet6_dev *idev,
 	if (!nla)
 		goto nla_put_failure;
 	read_lock_bh(&idev->lock);
-	memcpy(nla_data(nla), idev->token.s6_addr, nla_len(nla));
+	memcpy(nla_data(nla), idev->token->s6_addr, nla_len(nla));
 	read_unlock_bh(&idev->lock);
 
 	if (nla_put_u8(skb, IFLA_INET6_ADDR_GEN_MODE, idev->cnf.addr_gen_mode))
@@ -5809,7 +5831,7 @@ static int inet6_set_iftoken(struct inet6_dev *idev, struct in6_addr *token,
 	write_lock_bh(&idev->lock);
 
 	BUILD_BUG_ON(sizeof(token->s6_addr) != 16);
-	memcpy(idev->token.s6_addr + 8, token->s6_addr + 8, 8);
+	memcpy(idev->token->s6_addr + 8, token->s6_addr + 8, 8);
 
 	write_unlock_bh(&idev->lock);
 
@@ -6183,7 +6205,7 @@ static void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)
 			ip6_ins_rt(net, ifp->rt);
 		} else if (!ifp->rt && (ifp->idev->dev->flags & IFF_UP)) {
 			pr_warn("BUG: Address %pI6c on device %s is missing its host route.\n",
-				&ifp->addr, ifp->idev->dev->name);
+				ifp->addr, ifp->idev->dev->name);
 		}
 
 		if (ifp->idev->cnf.forwarding)
@@ -6196,7 +6218,7 @@ static void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)
 	case RTM_DELADDR:
 		if (ifp->idev->cnf.forwarding)
 			addrconf_leave_anycast(ifp);
-		addrconf_leave_solict(ifp->idev, &ifp->addr);
+		addrconf_leave_solict(ifp->idev, ifp->addr);
 		if (!ipv6_addr_any(&ifp->peer_addr)) {
 			struct fib6_info *rt;
 
diff --git a/net/ipv6/addrconf_core.c b/net/ipv6/addrconf_core.c
index 1d4054bb345b..c50f8d098067 100644
--- a/net/ipv6/addrconf_core.c
+++ b/net/ipv6/addrconf_core.c
@@ -247,6 +247,7 @@ static void in6_dev_finish_destroy_rcu(struct rcu_head *head)
 	struct inet6_dev *idev = container_of(head, struct inet6_dev, rcu);
 
 	snmp6_free_dev(idev);
+	kfree(idev->token);
 	kfree(idev);
 }
 
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index a506e57c4032..dde735d5ee72 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -147,15 +147,19 @@ static __be32 addr_bit_set(const void *token, int fn_bit)
 struct fib6_info *fib6_info_alloc(gfp_t gfp_flags, bool with_fib6_nh)
 {
 	struct fib6_info *f6i;
-	size_t sz = sizeof(*f6i);
 
-	if (with_fib6_nh)
-		sz += sizeof(struct fib6_nh);
-
-	f6i = kzalloc(sz, gfp_flags);
+	f6i = kzalloc(sizeof(*f6i), gfp_flags);
 	if (!f6i)
 		return NULL;
 
+	if (with_fib6_nh) {
+		f6i->fib6_nh = kzalloc(sizeof(struct fib6_nh), gfp_flags | __GFP_IUBIK);
+		if (!f6i->fib6_nh) {
+			kfree(f6i);
+			return NULL;
+		}
+	}
+
 	/* fib6_siblings is a union with nh_list, so this initializes both */
 	INIT_LIST_HEAD(&f6i->fib6_siblings);
 	refcount_set(&f6i->fib6_ref, 1);
@@ -171,8 +175,10 @@ void fib6_info_destroy_rcu(struct rcu_head *head)
 
 	if (f6i->nh)
 		nexthop_put(f6i->nh);
-	else
+	else {
 		fib6_nh_release(f6i->fib6_nh);
+		kfree(f6i->fib6_nh);
+	}
 
 	ip_fib_metrics_put(f6i->fib6_metrics);
 	kfree(f6i);
diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c
index bc5d3188454d..b00b65bf13ff 100644
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@ -1113,7 +1113,7 @@ int ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev, __u8 dsfield,
 			if (!neigh)
 				goto tx_err_link_failure;
 
-			addr6 = (struct in6_addr *)&neigh->primary_key;
+			addr6 = (struct in6_addr *)neigh->primary_key;
 			addr_type = ipv6_addr_type(addr6);
 
 			if (addr_type == IPV6_ADDR_ANY)
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index 856edbe81e11..0998f6092fc4 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -325,7 +325,7 @@ static bool ndisc_key_eq(const struct neighbour *n, const void *pkey)
 
 static int ndisc_constructor(struct neighbour *neigh)
 {
-	struct in6_addr *addr = (struct in6_addr *)&neigh->primary_key;
+	struct in6_addr *addr = (struct in6_addr *)neigh->primary_key;
 	struct net_device *dev = neigh->dev;
 	struct inet6_dev *in6_dev;
 	struct neigh_parms *parms;
@@ -589,7 +589,7 @@ static void ndisc_send_unsol_na(struct net_device *dev)
 		    !(ifa->flags & IFA_F_OPTIMISTIC))
 			continue;
 
-		ndisc_send_na(dev, &in6addr_linklocal_allnodes, &ifa->addr,
+		ndisc_send_na(dev, &in6addr_linklocal_allnodes, ifa->addr,
 			      /*router=*/ !!idev->cnf.forwarding,
 			      /*solicited=*/ false, /*override=*/ true,
 			      /*inc_opt=*/ true);
@@ -721,7 +721,7 @@ static void ndisc_solicit(struct neighbour *neigh, struct sk_buff *skb)
 	struct in6_addr *saddr = NULL;
 	struct in6_addr mcaddr;
 	struct net_device *dev = neigh->dev;
-	struct in6_addr *target = (struct in6_addr *)&neigh->primary_key;
+	struct in6_addr *target = (struct in6_addr *)neigh->primary_key;
 	int probes = atomic_read(&neigh->probes);
 
 	if (skb && ipv6_chk_addr_and_flags(dev_net(dev), &ipv6_hdr(skb)->saddr,
@@ -845,7 +845,7 @@ static void ndisc_recv_ns(struct sk_buff *skb)
 					ND_PRINTK(2, notice,
 						  "%s: IPv6 DAD loopback for address %pI6c nonce %pM ignored\n",
 						  ifp->idev->dev->name,
-						  &ifp->addr, np);
+						  ifp->addr, np);
 					goto out;
 				}
 				/*
@@ -1021,7 +1021,7 @@ static void ndisc_recv_na(struct sk_buff *skb)
 		if (skb->pkt_type != PACKET_LOOPBACK)
 			ND_PRINTK(1, warn,
 				  "NA: %pM advertised our address %pI6c on %s!\n",
-				  eth_hdr(skb)->h_source, &ifp->addr, ifp->idev->dev->name);
+				  eth_hdr(skb)->h_source, ifp->addr, ifp->idev->dev->name);
 		in6_ifa_put(ifp);
 		return;
 	}
diff --git a/net/ipv6/netfilter/nf_tproxy_ipv6.c b/net/ipv6/netfilter/nf_tproxy_ipv6.c
index 3fe4f15e01dc..755a86bb3d83 100644
--- a/net/ipv6/netfilter/nf_tproxy_ipv6.c
+++ b/net/ipv6/netfilter/nf_tproxy_ipv6.c
@@ -25,7 +25,7 @@ nf_tproxy_laddr6(struct sk_buff *skb, const struct in6_addr *user_laddr,
 			if (ifa->flags & (IFA_F_TENTATIVE | IFA_F_DEPRECATED))
 				continue;
 
-			laddr = &ifa->addr;
+			laddr = ifa->addr;
 			break;
 		}
 		read_unlock_bh(&indev->lock);
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 7219faf77c65..4cc1b75be9ec 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -3856,6 +3856,8 @@ static struct fib6_info *ip6_route_info_create(struct fib6_config *cfg,
 	return ERR_PTR(err);
 out_free:
 	ip_fib_metrics_put(rt->fib6_metrics);
+	if (rt->fib6_nh)
+		kfree(rt->fib6_nh);
 	kfree(rt);
 	return ERR_PTR(err);
 }
@@ -4611,7 +4613,7 @@ void rt6_remove_prefsrc(struct inet6_ifaddr *ifp)
 	struct arg_dev_net_ip adni = {
 		.dev = ifp->idev->dev,
 		.net = net,
-		.addr = &ifp->addr,
+		.addr = ifp->addr,
 	};
 	fib6_clean_all(net, fib6_remove_prefsrc, &adni);
 }
@@ -6466,8 +6468,9 @@ static int __net_init ip6_route_net_init(struct net *net)
 	net->ipv6.fib6_null_entry = fib6_info_alloc(GFP_KERNEL, true);
 	if (!net->ipv6.fib6_null_entry)
 		goto out_ip6_dst_entries;
+	// omit copying the last 8 bytes as it will wipe the fib6_nh pointer
 	memcpy(net->ipv6.fib6_null_entry, &fib6_null_entry_template,
-	       sizeof(*net->ipv6.fib6_null_entry));
+	       sizeof(*net->ipv6.fib6_null_entry) - 8);
 
 	net->ipv6.ip6_null_entry = kmemdup(&ip6_null_entry_template,
 					   sizeof(*net->ipv6.ip6_null_entry),
@@ -6528,6 +6531,7 @@ static int __net_init ip6_route_net_init(struct net *net)
 	kfree(net->ipv6.ip6_null_entry);
 #endif
 out_fib6_null_entry:
+	kfree(net->ipv6.fib6_null_entry->fib6_nh);
 	kfree(net->ipv6.fib6_null_entry);
 out_ip6_dst_entries:
 	dst_entries_destroy(&net->ipv6.ip6_dst_ops);
@@ -6537,6 +6541,8 @@ static int __net_init ip6_route_net_init(struct net *net)
 
 static void __net_exit ip6_route_net_exit(struct net *net)
 {
+	if (net->ipv6.fib6_null_entry->fib6_nh)
+		kfree(net->ipv6.fib6_null_entry->fib6_nh);
 	kfree(net->ipv6.fib6_null_entry);
 	kfree(net->ipv6.ip6_null_entry);
 #ifdef CONFIG_IPV6_MULTIPLE_TABLES
diff --git a/net/ipv6/sit.c b/net/ipv6/sit.c
index 3bc02ab9ceac..4510a1cca0cf 100644
--- a/net/ipv6/sit.c
+++ b/net/ipv6/sit.c
@@ -892,7 +892,7 @@ static netdev_tx_t ipip6_tunnel_xmit(struct sk_buff *skb,
 			goto tx_error;
 		}
 
-		addr6 = (const struct in6_addr *)&neigh->primary_key;
+		addr6 = (const struct in6_addr *)neigh->primary_key;
 		addr_type = ipv6_addr_type(addr6);
 
 		if ((addr_type & IPV6_ADDR_UNICAST) &&
@@ -921,7 +921,7 @@ static netdev_tx_t ipip6_tunnel_xmit(struct sk_buff *skb,
 			goto tx_error;
 		}
 
-		addr6 = (const struct in6_addr *)&neigh->primary_key;
+		addr6 = (const struct in6_addr *)neigh->primary_key;
 		addr_type = ipv6_addr_type(addr6);
 
 		if (addr_type == IPV6_ADDR_ANY) {
diff --git a/net/netfilter/nf_nat_masquerade.c b/net/netfilter/nf_nat_masquerade.c
index acd73f717a08..fdb78c30a6fa 100644
--- a/net/netfilter/nf_nat_masquerade.c
+++ b/net/netfilter/nf_nat_masquerade.c
@@ -285,7 +285,7 @@ static int masq_inet6_event(struct notifier_block *this,
 
 	memset(&addr, 0, sizeof(addr));
 
-	addr.in6 = ifa->addr;
+	addr.in6 = *ifa->addr;
 
 	nf_nat_masq_schedule(dev_net(dev), &addr, dev->ifindex, inet_cmp,
 			     GFP_ATOMIC);
diff --git a/net/netfilter/nf_nat_redirect.c b/net/netfilter/nf_nat_redirect.c
index f91579c821e9..3ff561d0b796 100644
--- a/net/netfilter/nf_nat_redirect.c
+++ b/net/netfilter/nf_nat_redirect.c
@@ -98,7 +98,7 @@ nf_nat_redirect_ipv6(struct sk_buff *skb, const struct nf_nat_range2 *range,
 		if (idev != NULL) {
 			read_lock_bh(&idev->lock);
 			list_for_each_entry(ifa, &idev->addr_list, if_list) {
-				newdst = ifa->addr;
+				newdst = *ifa->addr;
 				addr = true;
 				break;
 			}
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 6dddace22cc7..06242a94dce2 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -1296,7 +1296,7 @@ static int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info *info,
 		goto err_strdup;
 
 	if (nla[NFTA_TABLE_USERDATA]) {
-		table->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL);
+		table->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL | __GFP_IUBIK);
 		if (table->udata == NULL)
 			goto err_table_udata;
 
@@ -3386,6 +3386,8 @@ void nf_tables_rule_destroy(const struct nft_ctx *ctx, struct nft_rule *rule)
 		nf_tables_expr_destroy(ctx, expr);
 		expr = next;
 	}
+	if (rule->udata)
+		kfree(nft_userdata(rule)->data);
 	kfree(rule);
 }
 
@@ -3628,7 +3630,7 @@ static int nf_tables_newrule(struct sk_buff *skb, const struct nfnl_info *info,
 	if (nla[NFTA_RULE_USERDATA]) {
 		ulen = nla_len(nla[NFTA_RULE_USERDATA]);
 		if (ulen > 0)
-			usize = sizeof(struct nft_userdata) + ulen;
+			usize = sizeof(struct nft_userdata);
 	}
 
 	err = -ENOMEM;
@@ -3644,6 +3646,9 @@ static int nf_tables_newrule(struct sk_buff *skb, const struct nfnl_info *info,
 
 	if (ulen) {
 		udata = nft_userdata(rule);
+		udata->data = kzalloc(ulen, GFP_KERNEL | __GFP_IUBIK);
+		if (!udata->data)
+			goto err_release_rule;
 		udata->len = ulen - 1;
 		nla_memcpy(udata->data, nla[NFTA_RULE_USERDATA], ulen);
 	}
@@ -4737,7 +4742,7 @@ static int nf_tables_newset(struct sk_buff *skb, const struct nfnl_info *info,
 	size = 0;
 	if (ops->privsize != NULL)
 		size = ops->privsize(nla, &desc);
-	alloc_size = sizeof(*set) + size + udlen;
+	alloc_size = sizeof(*set) + size;
 	if (alloc_size < size || alloc_size > INT_MAX)
 		return -ENOMEM;
 
@@ -4763,7 +4768,11 @@ static int nf_tables_newset(struct sk_buff *skb, const struct nfnl_info *info,
 
 	udata = NULL;
 	if (udlen) {
-		udata = set->data + size;
+		udata = kvzalloc(udlen, GFP_KERNEL | __GFP_IUBIK);
+		if (!udata) {
+			err = -ENOMEM;
+			goto err_alloc_udata;
+		}
 		nla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);
 	}
 
@@ -4816,6 +4825,8 @@ static int nf_tables_newset(struct sk_buff *skb, const struct nfnl_info *info,
 err_set_destroy:
 	ops->destroy(&ctx, set);
 err_set_init:
+	kvfree(set->udata);
+err_alloc_udata:
 	kfree(set->name);
 err_set_name:
 	kvfree(set);
@@ -4841,6 +4852,7 @@ static void nft_set_put(struct nft_set *set)
 {
 	if (refcount_dec_and_test(&set->refs)) {
 		kfree(set->name);
+		kvfree(set->udata);
 		kvfree(set);
 	}
 }
@@ -5839,6 +5851,12 @@ void nft_set_elem_destroy(const struct nft_set *set, void *elem,
 
 	if (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF))
 		nft_use_dec(&(*nft_set_ext_obj(ext))->use);
+
+	if (nft_set_ext_exists(ext, NFT_SET_EXT_USERDATA)) {
+		struct nft_userdata *udata = nft_set_ext_userdata(ext);
+		kfree(udata->data);
+	}
+
 	kfree(elem);
 }
 EXPORT_SYMBOL_GPL(nft_set_elem_destroy);
@@ -5853,6 +5871,11 @@ void nf_tables_set_elem_destroy(const struct nft_ctx *ctx,
 
 	if (nft_set_ext_exists(ext, NFT_SET_EXT_EXPRESSIONS))
 		nft_set_elem_expr_destroy(ctx, nft_set_ext_expr(ext));
+	
+	if (nft_set_ext_exists(ext, NFT_SET_EXT_USERDATA)) {
+		struct nft_userdata *udata = nft_set_ext_userdata(ext);
+		kfree(udata->data);
+	}
 
 	kfree(elem);
 }
@@ -6013,6 +6036,11 @@ static int nft_setelem_catchall_deactivate(const struct net *net,
 		if (!nft_is_active(net, ext))
 			continue;
 
+		if (nft_set_ext_exists(ext, NFT_SET_EXT_USERDATA)) {
+			struct nft_userdata *udata = nft_set_ext_userdata(ext);
+			kfree(udata->data);
+		}
+
 		kfree(elem->priv);
 		elem->priv = catchall->elem;
 		nft_set_elem_change_active(net, set, ext);
@@ -6027,11 +6055,18 @@ static int __nft_setelem_deactivate(const struct net *net,
 				    struct nft_set_elem *elem)
 {
 	void *priv;
+	struct nft_set_ext *ext;
 
 	priv = set->ops->deactivate(net, set, elem);
 	if (!priv)
 		return -ENOENT;
 
+	ext = nft_set_elem_ext(set, elem->priv);
+	if (nft_set_ext_exists(ext, NFT_SET_EXT_USERDATA)) {
+		struct nft_userdata *udata = nft_set_ext_userdata(ext);
+		kfree(udata->data);
+	}
+	
 	kfree(elem->priv);
 	elem->priv = priv;
 	set->ndeact++;
@@ -6389,7 +6424,10 @@ static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
 	if (ulen > 0) {
 		udata = nft_set_ext_userdata(ext);
 		udata->len = ulen - 1;
-		nla_memcpy(&udata->data, nla[NFTA_SET_ELEM_USERDATA], ulen);
+		udata->data = kzalloc(ulen, GFP_KERNEL | __GFP_IUBIK);
+		if (!udata->data)
+			goto err_elem_expr;
+		nla_memcpy(udata->data, nla[NFTA_SET_ELEM_USERDATA], ulen);
 	}
 	if (obj)
 		*nft_set_ext_obj(ext) = obj;
@@ -6648,6 +6686,10 @@ static int nft_del_setelem(struct nft_ctx *ctx, struct nft_set *set,
 fail_ops:
 	kfree(trans);
 fail_trans:
+	if (nft_set_ext_exists(ext, NFT_SET_EXT_USERDATA)) {
+		struct nft_userdata *udata = nft_set_ext_userdata(ext);
+		kfree(udata->data);
+	}
 	kfree(elem.priv);
 fail_elem_key_end:
 	nft_data_release(&elem.key_end.val, NFT_DATA_VALUE);
@@ -7092,14 +7134,14 @@ static int nf_tables_newobj(struct sk_buff *skb, const struct nfnl_info *info,
 	obj->key.table = table;
 	obj->handle = nf_tables_alloc_handle(table);
 
-	obj->key.name = nla_strdup(nla[NFTA_OBJ_NAME], GFP_KERNEL);
+	obj->key.name = nla_strdup(nla[NFTA_OBJ_NAME], GFP_KERNEL | __GFP_IUBIK);
 	if (!obj->key.name) {
 		err = -ENOMEM;
 		goto err_strdup;
 	}
 
 	if (nla[NFTA_OBJ_USERDATA]) {
-		obj->udata = nla_memdup(nla[NFTA_OBJ_USERDATA], GFP_KERNEL);
+		obj->udata = nla_memdup(nla[NFTA_OBJ_USERDATA], GFP_KERNEL | __GFP_IUBIK);
 		if (obj->udata == NULL)
 			goto err_userdata;
 
diff --git a/net/netfilter/nft_log.c b/net/netfilter/nft_log.c
index 54f6c2035e84..646057ff3b08 100644
--- a/net/netfilter/nft_log.c
+++ b/net/netfilter/nft_log.c
@@ -163,7 +163,7 @@ static int nft_log_init(const struct nft_ctx *ctx,
 
 	nla = tb[NFTA_LOG_PREFIX];
 	if (nla != NULL) {
-		priv->prefix = kmalloc(nla_len(nla) + 1, GFP_KERNEL);
+		priv->prefix = kmalloc(nla_len(nla) + 1, GFP_KERNEL | __GFP_IUBIK);
 		if (priv->prefix == NULL)
 			return -ENOMEM;
 		nla_strscpy(priv->prefix, nla, nla_len(nla) + 1);
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index b69fbee47355..4cb7bf4b3abf 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -4284,7 +4284,7 @@ static char *alloc_one_pg_vec_page(unsigned long order)
 {
 	char *buffer;
 	gfp_t gfp_flags = GFP_KERNEL | __GFP_COMP |
-			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;
+			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY | __GFP_IUBIK;
 
 	buffer = (char *) __get_free_pages(gfp_flags, order);
 	if (buffer)
diff --git a/net/qrtr/ns.c b/net/qrtr/ns.c
index 3e40a1ba48f7..390e3c28211d 100644
--- a/net/qrtr/ns.c
+++ b/net/qrtr/ns.c
@@ -679,7 +679,7 @@ static void qrtr_ns_worker(struct work_struct *work)
 	msg.msg_name = (struct sockaddr *)&sq;
 	msg.msg_namelen = sizeof(sq);
 
-	recv_buf = kzalloc(recv_buf_size, GFP_KERNEL);
+	recv_buf = kzalloc(recv_buf_size, GFP_KERNEL | __GFP_IUBIK);
 	if (!recv_buf)
 		return;
 
diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c
index 470dbdc27d58..679469600452 100644
--- a/net/sctp/ipv6.c
+++ b/net/sctp/ipv6.c
@@ -86,7 +86,7 @@ static int sctp_inet6addr_event(struct notifier_block *this, unsigned long ev,
 		addr = kzalloc(sizeof(*addr), GFP_ATOMIC);
 		if (addr) {
 			addr->a.v6.sin6_family = AF_INET6;
-			addr->a.v6.sin6_addr = ifa->addr;
+			addr->a.v6.sin6_addr = *ifa->addr;
 			addr->a.v6.sin6_scope_id = ifa->idev->dev->ifindex;
 			addr->valid = 1;
 			spin_lock_bh(&net->sctp.local_addr_lock);
@@ -101,7 +101,7 @@ static int sctp_inet6addr_event(struct notifier_block *this, unsigned long ev,
 					&net->sctp.local_addr_list, list) {
 			if (addr->a.sa.sa_family == AF_INET6 &&
 			    ipv6_addr_equal(&addr->a.v6.sin6_addr,
-					    &ifa->addr) &&
+					    ifa->addr) &&
 			    addr->a.v6.sin6_scope_id == ifa->idev->dev->ifindex) {
 				sctp_addr_wq_mgmt(net, addr, SCTP_ADDR_DEL);
 				found = 1;
@@ -474,7 +474,7 @@ static void sctp_v6_copy_addrlist(struct list_head *addrlist,
 		addr = kzalloc(sizeof(*addr), GFP_ATOMIC);
 		if (addr) {
 			addr->a.v6.sin6_family = AF_INET6;
-			addr->a.v6.sin6_addr = ifp->addr;
+			addr->a.v6.sin6_addr = *ifp->addr;
 			addr->a.v6.sin6_scope_id = dev->ifindex;
 			addr->valid = 1;
 			INIT_LIST_HEAD(&addr->list);
diff --git a/net/smc/smc_clc.c b/net/smc/smc_clc.c
index 6ec1ebe878ae..30e2abe5713a 100644
--- a/net/smc/smc_clc.c
+++ b/net/smc/smc_clc.c
@@ -194,10 +194,10 @@ static int smc_clc_prfx_set6_rcu(struct dst_entry *dst,
 		return -ENODEV;
 	/* use a maximum of 8 IPv6 prefixes from device */
 	list_for_each_entry(ifa, &in6_dev->addr_list, if_list) {
-		if (ipv6_addr_type(&ifa->addr) & IPV6_ADDR_LINKLOCAL)
+		if (ipv6_addr_type(ifa->addr) & IPV6_ADDR_LINKLOCAL)
 			continue;
 		ipv6_addr_prefix(&ipv6_prfx[cnt].prefix,
-				 &ifa->addr, ifa->prefix_len);
+				 ifa->addr, ifa->prefix_len);
 		ipv6_prfx[cnt].prefix_len = ifa->prefix_len;
 		cnt++;
 		if (cnt == SMC_CLC_MAX_V6_PREFIX)
@@ -288,11 +288,11 @@ static int smc_clc_prfx_match6_rcu(struct net_device *dev,
 	ipv6_prfx = (struct smc_clc_ipv6_prefix *)((u8 *)prop + sizeof(*prop));
 	max = min_t(u8, prop->ipv6_prefixes_cnt, SMC_CLC_MAX_V6_PREFIX);
 	list_for_each_entry(ifa, &in6_dev->addr_list, if_list) {
-		if (ipv6_addr_type(&ifa->addr) & IPV6_ADDR_LINKLOCAL)
+		if (ipv6_addr_type(ifa->addr) & IPV6_ADDR_LINKLOCAL)
 			continue;
 		for (i = 0; i < max; i++) {
 			if (ifa->prefix_len == ipv6_prfx[i].prefix_len &&
-			    ipv6_prefix_equal(&ifa->addr, &ipv6_prfx[i].prefix,
+			    ipv6_prefix_equal(ifa->addr, &ipv6_prfx[i].prefix,
 					      ifa->prefix_len))
 				return 0;
 		}
diff --git a/net/tipc/crypto.c b/net/tipc/crypto.c
index 86d1e782b8fc..effc7768e080 100644
--- a/net/tipc/crypto.c
+++ b/net/tipc/crypto.c
@@ -424,7 +424,9 @@ static void tipc_aead_free(struct rcu_head *rp)
 		kfree(head);
 	}
 	free_percpu(aead->tfm_entry);
-	kfree_sensitive(aead->key);
+	kfree(aead->key->alg_name);
+	kfree_sensitive(aead->key->key);
+	kfree(aead->key);
 	kfree(aead);
 }
 
@@ -596,11 +598,25 @@ static int tipc_aead_init(struct tipc_aead **aead, struct tipc_aead_key *ukey,
 	tmp->mode = mode;
 	tmp->cloned = NULL;
 	tmp->authsize = TIPC_AES_GCM_TAG_SIZE;
-	tmp->key = kmemdup(ukey, tipc_aead_key_size(ukey), GFP_KERNEL);
+	
+	tmp->key = kmalloc(sizeof(struct tipc_aead_key), GFP_KERNEL);
 	if (!tmp->key) {
 		tipc_aead_free(&tmp->rcu);
 		return -ENOMEM;
 	}
+	tmp->key->keylen = ukey->keylen;
+	tmp->key->key = kmemdup(ukey->key, ukey->keylen, GFP_KERNEL | __GFP_IUBIK);
+	if (!tmp->key->key) {
+		tipc_aead_free(&tmp->rcu);
+		return -ENOMEM;
+	}
+	tmp->key->alg_name = kmemdup(ukey->alg_name, sizeof__tipc_key__alg_name, 
+		GFP_ATOMIC | __GFP_IUBIK);
+	if (!tmp->key->alg_name) {
+		tipc_aead_free(&tmp->rcu);
+		return -ENOMEM;
+	}
+
 	memcpy(&tmp->salt, ukey->key + keylen, TIPC_AES_GCM_SALT_SIZE);
 	atomic_set(&tmp->users, 0);
 	atomic64_set(&tmp->seqno, 0);
@@ -2318,12 +2334,28 @@ static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
 	}
 
 	/* Allocate memory for the key */
-	skey = kmalloc(size, GFP_ATOMIC);
+	skey = kmalloc(sizeof(struct tipc_aead_key), GFP_ATOMIC);
 	if (unlikely(!skey)) {
 		pr_err("%s: unable to allocate memory for skey\n", rx->name);
 		goto exit_unlock;
 	}
 
+	skey->alg_name = kmalloc(sizeof__tipc_key__alg_name, GFP_ATOMIC | __GFP_IUBIK);
+	if (unlikely(!skey)) {
+		kfree(skey);
+		pr_err("%s: unable to allocate memory for skey->alg_name\n", rx->name);
+		goto exit_unlock;
+	}
+
+	skey->key = kmalloc(keylen, GFP_ATOMIC | __GFP_IUBIK);
+	if (unlikely(!skey)) {
+		kfree(skey->alg_name);
+		kfree(skey);
+		pr_err("%s: unable to allocate memory for skey->key\n", rx->name);
+		goto exit_unlock;
+	}
+
+
 	/* Copy key from msg data */
 	skey->keylen = keylen;
 	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
@@ -2396,6 +2428,8 @@ static void tipc_crypto_work_rx(struct work_struct *work)
 			break;
 		default:
 			synchronize_rcu();
+			kfree(rx->skey->alg_name);
+			kfree(rx->skey->key);
 			kfree(rx->skey);
 			rx->skey = NULL;
 			break;
@@ -2465,17 +2499,27 @@ static void tipc_crypto_work_tx(struct work_struct *work)
 	}
 
 	/* Lets duplicate it first */
-	skey = kmemdup(aead->key, tipc_aead_key_size(aead->key), GFP_ATOMIC);
+	skey = kmalloc(sizeof(struct tipc_aead_key), GFP_ATOMIC);
+	if (unlikely(!skey)) {
+		rcu_read_unlock();
+		return;
+	}
+	skey->keylen = aead->key->keylen;
+	skey->key = kmemdup(aead->key->key, skey->keylen, GFP_ATOMIC | __GFP_IUBIK);
+	skey->alg_name = kmemdup(aead->key->alg_name, sizeof__tipc_key__alg_name, 
+		GFP_ATOMIC | __GFP_IUBIK);
 	rcu_read_unlock();
 
 	/* Now, generate new key, initiate & distribute it */
-	if (likely(skey)) {
+	if (likely(skey->key) && likely(skey->alg_name)) {
 		rc = tipc_aead_key_generate(skey) ?:
 		     tipc_crypto_key_init(tx, skey, PER_NODE_KEY, false);
 		if (likely(rc > 0))
 			rc = tipc_crypto_key_distr(tx, rc, NULL);
-		kfree_sensitive(skey);
 	}
+	kfree(skey->alg_name);
+	kfree_sensitive(skey->key);
+	kfree(skey);
 
 	if (unlikely(rc))
 		pr_warn_ratelimited("%s: rekeying returns %d\n", tx->name, rc);
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index 807fcd09359f..6c1da803b749 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -216,8 +216,10 @@ EXPORT_SYMBOL_GPL(unix_peer_get);
 
 static inline void unix_release_addr(struct unix_address *addr)
 {
-	if (refcount_dec_and_test(&addr->refcnt))
+	if (refcount_dec_and_test(&addr->refcnt)) {
+		kfree(addr->name);
 		kfree(addr);
+	}
 }
 
 /*
@@ -971,9 +973,15 @@ static int unix_autobind(struct socket *sock)
 		goto out;
 
 	err = -ENOMEM;
-	addr = kzalloc(sizeof(*addr) + sizeof(short) + 16, GFP_KERNEL);
+	addr = kzalloc(sizeof(*addr), GFP_KERNEL);
 	if (!addr)
 		goto out;
+	
+	addr->name = kzalloc(sizeof(short) + 16, GFP_KERNEL_IUBIK);
+	if (!addr->name) {
+		kfree(addr);
+		goto out;
+	}
 
 	addr->name->sun_family = AF_UNIX;
 	refcount_set(&addr->refcnt, 1);
@@ -996,6 +1004,7 @@ static int unix_autobind(struct socket *sock)
 		/* Give up if all names seems to be in use. */
 		if (retries++ == 0xFFFFF) {
 			err = -ENOSPC;
+			kfree(addr->name);
 			kfree(addr);
 			goto out;
 		}
@@ -1168,9 +1177,15 @@ static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 	if (err < 0)
 		return err;
 	addr_len = err;
-	addr = kmalloc(sizeof(*addr)+addr_len, GFP_KERNEL);
+	addr = kmalloc(sizeof(*addr), GFP_KERNEL);
 	if (!addr)
 		return -ENOMEM;
+	
+	addr->name = kmalloc(addr_len, GFP_KERNEL_IUBIK);
+	if (!addr->name) {
+		kfree(addr);
+		return -ENOMEM;
+	}
 
 	memcpy(addr->name, sunaddr, addr_len);
 	addr->len = addr_len;
diff --git a/scripts/clang-tools/gen_compile_commands.py b/scripts/clang-tools/gen_compile_commands.py
index 47da25b3ba7d..a77c756a587e 100755
--- a/scripts/clang-tools/gen_compile_commands.py
+++ b/scripts/clang-tools/gen_compile_commands.py
@@ -184,7 +184,7 @@ def process_line(root_directory, command_prefix, file_path):
     # escape the pound sign '#', either as '\#' or '$(pound)' (depending on the
     # kernel version). The compile_commands.json file is not interepreted
     # by Make, so this code replaces the escaped version with '#'.
-    prefix = command_prefix.replace('\#', '#').replace('$(pound)', '#')
+    prefix = command_prefix.replace('#', '#').replace('$(pound)', '#')
 
     # Use os.path.abspath() to normalize the path resolving '.' and '..' .
     abs_path = os.path.abspath(os.path.join(root_directory, file_path))
diff --git a/security/keys/key.c b/security/keys/key.c
index c45afdd1dfbb..bf69a5827b64 100644
--- a/security/keys/key.c
+++ b/security/keys/key.c
@@ -279,7 +279,7 @@ struct key *key_alloc(struct key_type *type, const char *desc,
 		goto no_memory_2;
 
 	key->index_key.desc_len = desclen;
-	key->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);
+	key->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL | __GFP_IUBIK);
 	if (!key->index_key.description)
 		goto no_memory_3;
 	key->index_key.type = type;
diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c
index cfb500087692..2ed69f59d207 100644
--- a/security/keys/keyctl.c
+++ b/security/keys/keyctl.c
@@ -113,7 +113,7 @@ SYSCALL_DEFINE5(add_key, const char __user *, _type,
 
 	if (plen) {
 		ret = -ENOMEM;
-		payload = kvmalloc(plen, GFP_KERNEL);
+		payload = kvmalloc(plen, GFP_KERNEL | __GFP_IUBIK);
 		if (!payload)
 			goto error2;
 
diff --git a/security/keys/keyring.c b/security/keys/keyring.c
index 5e6a90760753..cf34cfad52e9 100644
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@ -214,10 +214,7 @@ static void hash_key_type_and_desc(struct keyring_index_key *index_key)
 void key_set_index_key(struct keyring_index_key *index_key)
 {
 	static struct key_tag default_domain_tag = { .usage = REFCOUNT_INIT(1), };
-	size_t n = min_t(size_t, index_key->desc_len, sizeof(index_key->desc));
-
-	memcpy(index_key->desc, index_key->description, n);
-
+	
 	if (!index_key->domain_tag) {
 		if (index_key->type->flags & KEY_TYPE_NET_DOMAIN)
 			index_key->domain_tag = current->nsproxy->net_ns->key_domain;
@@ -277,19 +274,19 @@ static unsigned long keyring_get_key_chunk(const void *data, int level)
 	case 0:
 		return index_key->hash;
 	case 1:
-		return index_key->x;
+		return index_key_x(index_key);
 	case 2:
 		return (unsigned long)index_key->type;
 	case 3:
 		return (unsigned long)index_key->domain_tag;
 	default:
 		level -= 4;
-		if (desc_len <= sizeof(index_key->desc))
+		if (desc_len <= (sizeof(long) - 2))
 			return 0;
 
-		d = index_key->description + sizeof(index_key->desc);
+		d = index_key->description + (sizeof(long) - 2);
 		d += level * sizeof(long);
-		desc_len -= sizeof(index_key->desc);
+		desc_len -= (sizeof(long) - 2);
 		if (desc_len > n)
 			desc_len = n;
 		do {
@@ -341,8 +338,8 @@ static int keyring_diff_objects(const void *object, const void *data)
 	 * constant in the assoc_array headers.  Everything else thereafter we
 	 * can deal with as being machine word-size dependent.
 	 */
-	seg_a = a->x;
-	seg_b = b->x;
+	seg_a = index_key_x(a);
+	seg_b = index_key_x(b);
 	if ((seg_a ^ seg_b) != 0)
 		goto differ;
 	level += sizeof(unsigned long);
@@ -360,7 +357,7 @@ static int keyring_diff_objects(const void *object, const void *data)
 		goto differ;
 	level += sizeof(unsigned long);
 
-	i = sizeof(a->desc);
+	i = sizeof(long) - 2;
 	if (a->desc_len <= i)
 		goto same;
 
diff --git a/security/keys/user_defined.c b/security/keys/user_defined.c
index 749e2a4dcb13..9067d3916113 100644
--- a/security/keys/user_defined.c
+++ b/security/keys/user_defined.c
@@ -64,10 +64,16 @@ int user_preparse(struct key_preparsed_payload *prep)
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
-	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
+	upayload = kmalloc(sizeof(*upayload), GFP_KERNEL);
 	if (!upayload)
 		return -ENOMEM;
 
+	upayload->data = kmalloc(datalen, GFP_KERNEL_IUBIK);
+	if (!upayload->data) {
+		kfree(upayload);
+		return -ENOMEM;
+	}
+
 	/* attach the data */
 	prep->quotalen = datalen;
 	prep->payload.data[0] = upayload;
@@ -82,7 +88,9 @@ EXPORT_SYMBOL_GPL(user_preparse);
  */
 void user_free_preparse(struct key_preparsed_payload *prep)
 {
-	kfree_sensitive(prep->payload.data[0]);
+	struct user_key_payload *payload = prep->payload.data[0];
+	kfree_sensitive(payload->data);
+	kfree(payload);
 }
 EXPORT_SYMBOL_GPL(user_free_preparse);
 
@@ -91,7 +99,8 @@ static void user_free_payload_rcu(struct rcu_head *head)
 	struct user_key_payload *payload;
 
 	payload = container_of(head, struct user_key_payload, rcu);
-	kfree_sensitive(payload);
+	kfree_sensitive(payload->data);
+	kfree(payload);
 }
 
 /*
@@ -147,7 +156,8 @@ void user_destroy(struct key *key)
 {
 	struct user_key_payload *upayload = key->payload.data[0];
 
-	kfree_sensitive(upayload);
+	kfree_sensitive(upayload->data);
+	kfree(upayload);
 }
 
 EXPORT_SYMBOL_GPL(user_destroy);
diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c
index b1632ab432cf..9b73aba39d0c 100644
--- a/sound/core/rawmidi.c
+++ b/sound/core/rawmidi.c
@@ -159,7 +159,7 @@ static int snd_rawmidi_runtime_create(struct snd_rawmidi_substream *substream)
 		runtime->avail = 0;
 	else
 		runtime->avail = runtime->buffer_size;
-	runtime->buffer = kvzalloc(runtime->buffer_size, GFP_KERNEL);
+	runtime->buffer = kvzalloc(runtime->buffer_size, GFP_KERNEL | __GFP_IUBIK);
 	if (!runtime->buffer) {
 		kfree(runtime);
 		return -ENOMEM;
@@ -690,7 +690,7 @@ static int resize_runtime_buffer(struct snd_rawmidi_runtime *runtime,
 	if (params->avail_min < 1 || params->avail_min > params->buffer_size)
 		return -EINVAL;
 	if (params->buffer_size != runtime->buffer_size) {
-		newbuf = kvzalloc(params->buffer_size, GFP_KERNEL);
+		newbuf = kvzalloc(params->buffer_size, GFP_KERNEL | __GFP_IUBIK);
 		if (!newbuf)
 			return -ENOMEM;
 		spin_lock_irq(&runtime->lock);
diff --git a/sound/sound_core.c b/sound/sound_core.c
index 90d118cd9164..b929beb8e663 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -34,7 +34,7 @@ static char *sound_devnode(struct device *dev, umode_t *mode)
 {
 	if (MAJOR(dev->devt) == SOUND_MAJOR)
 		return NULL;
-	return kasprintf(GFP_KERNEL, "snd/%s", dev_name(dev));
+	return kasprintf(GFP_KERNEL | __GFP_IUBIK, "snd/%s", dev_name(dev));
 }
 
 static int __init init_soundcore(void)
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 88f4d18131b5..12e2080f0529 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -5499,6 +5499,12 @@ static void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm)
 	if (!env)
 		return;
 
+	env->buf = kzalloc(sizeof__kobj_uevent_env__buf, GFP_KERNEL_IUBIK);
+	if (!env->buf) {
+		kfree(env);
+		return;
+	}
+
 	add_uevent_var(env, "CREATED=%llu", created);
 	add_uevent_var(env, "COUNT=%llu", active);
 
@@ -5523,6 +5529,7 @@ static void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm)
 	/* no need for checks, since we are adding at most only 5 keys */
 	env->envp[env->envp_idx++] = NULL;
 	kobject_uevent_env(&kvm_dev.this_device->kobj, KOBJ_CHANGE, env->envp);
+	kfree(env->buf);
 	kfree(env);
 }
 
